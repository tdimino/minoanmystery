---
// Lightbox component for image galleries
// Native <dialog> with @starting-style animations, View Transitions morphing,
// pointer-event swipe gestures, and structured metadata captions.
//
// Usage: Add data-lightbox to trigger elements containing an <img>.
// Pass galleries prop for predefined gallery groups with captions/metadata.

interface GalleryImage {
  src: string;
  caption: string;
  title?: string;
  year?: string;
  description?: string;
  tags?: string[];
  link?: { url: string; label: string };
  circular?: boolean;
}

interface Gallery {
  id: string;
  trigger: string; // filename that triggers this gallery
  images: GalleryImage[];
}

interface Props {
  galleries?: Gallery[];
}

const { galleries = [] } = Astro.props;
---

<dialog id="lightbox-overlay" class="lightbox-overlay" closedby="any" aria-label="Image lightbox">
  <button class="lightbox-close" aria-label="Close lightbox">&times;</button>
  <button class="lightbox-prev" aria-label="Previous image">&#8249;</button>
  <button class="lightbox-next" aria-label="Next image">&#8250;</button>
  <div class="lightbox-content">
    <img id="lightbox-img" src="" alt="" />
    <div class="lightbox-caption"></div>
  </div>
  <div class="lightbox-counter" aria-live="polite"></div>
</dialog>

<!-- Store gallery data for JS access -->
<script id="gallery-data" type="application/json" set:html={JSON.stringify(galleries)} />

<style is:global>
  /* ── Dialog base ── */
  dialog#lightbox-overlay {
    --lightbox-accent: #c9a0b8;
    --lightbox-accent-rgb: 201, 160, 184;

    position: fixed;
    inset: 0;
    width: 100%;
    height: 100%;
    max-width: 100%;
    max-height: 100%;
    margin: 0;
    padding: 0;
    border: none;
    background: transparent;
    color: #fff;

    display: flex;
    align-items: center;
    justify-content: center;

    /* Entry/exit transitions */
    opacity: 1;
    scale: 1;
    transition:
      opacity 0.25s ease,
      scale 0.2s cubic-bezier(0.16, 1, 0.3, 1),
      overlay 0.25s ease allow-discrete,
      display 0.25s ease allow-discrete;
  }

  /* Entry animation starting state */
  @starting-style {
    dialog#lightbox-overlay {
      opacity: 0;
      scale: 0.96;
    }
  }

  /* Exit animation end state */
  dialog#lightbox-overlay:not([open]) {
    opacity: 0;
    scale: 0.96;
  }

  /* Skip dialog entry animation when View Transitions handles the open morph */
  dialog#lightbox-overlay[data-vt-open],
  dialog#lightbox-overlay[data-vt-open]::backdrop {
    transition: none;
    opacity: 1;
    scale: 1;
  }

  dialog#lightbox-overlay[data-vt-open]::backdrop {
    background: rgba(0, 0, 0, 0.88);
    backdrop-filter: blur(12px) saturate(120%);
    -webkit-backdrop-filter: blur(12px) saturate(120%);
  }

  /* Skip dialog exit animation when View Transitions handles the close morph */
  dialog#lightbox-overlay[data-vt-close],
  dialog#lightbox-overlay[data-vt-close]::backdrop {
    transition: none;
  }

  /* ── Backdrop ── */
  dialog#lightbox-overlay::backdrop {
    background: rgba(0, 0, 0, 0.88);
    backdrop-filter: blur(12px) saturate(120%);
    -webkit-backdrop-filter: blur(12px) saturate(120%);
    transition:
      background-color 0.25s ease,
      backdrop-filter 0.25s ease,
      -webkit-backdrop-filter 0.25s ease,
      overlay 0.25s ease allow-discrete,
      display 0.25s ease allow-discrete;
  }

  @starting-style {
    dialog#lightbox-overlay::backdrop {
      background: rgba(0, 0, 0, 0);
      backdrop-filter: blur(0px) saturate(100%);
      -webkit-backdrop-filter: blur(0px) saturate(100%);
    }
  }

  dialog#lightbox-overlay:not([open])::backdrop {
    background: rgba(0, 0, 0, 0);
    backdrop-filter: blur(0px) saturate(100%);
    -webkit-backdrop-filter: blur(0px) saturate(100%);
  }

  /* ── View Transition morph ── */
  ::view-transition-group(lightbox-hero) {
    animation-duration: 300ms;
    animation-timing-function: cubic-bezier(0.16, 1, 0.3, 1);
  }

  /* ── Reduced motion ── */
  @media (prefers-reduced-motion: reduce) {
    dialog#lightbox-overlay,
    dialog#lightbox-overlay::backdrop {
      transition: none;
    }
    .lightbox-content img.lightbox-img--circular {
      animation: none;
    }
  }

  /* ── Content area ── */
  .lightbox-content {
    max-width: 90vw;
    max-height: 85vh;
    display: flex;
    flex-direction: column;
    align-items: center;
    padding: 2rem 2.5rem;
    position: relative;
    touch-action: pinch-zoom;
  }

  .lightbox-content img {
    max-width: 100%;
    max-height: 55vh;
    object-fit: contain;
    border-radius: 8px;
  }

  /* Invert dark logos on lightbox's dark background */
  .lightbox-content img.lightbox-img--invert {
    filter: invert(1) brightness(0.9);
  }

  /* Circular images (avatars) — matches labyrinth chat avatar glow */
  .lightbox-content img.lightbox-img--circular {
    border-radius: 50%;
    border: 2px solid rgba(var(--lightbox-accent-rgb), 0.4);
    box-shadow:
      0 0 16px rgba(var(--lightbox-accent-rgb), 0.25),
      0 0 40px rgba(var(--lightbox-accent-rgb), 0.1);
    animation: lightbox-avatar-glow 3s ease-in-out infinite alternate;
  }

  @keyframes lightbox-avatar-glow {
    0% {
      box-shadow:
        0 0 16px rgba(var(--lightbox-accent-rgb), 0.25),
        0 0 40px rgba(var(--lightbox-accent-rgb), 0.1);
    }
    100% {
      box-shadow:
        0 0 20px rgba(var(--lightbox-accent-rgb), 0.35),
        0 0 50px rgba(var(--lightbox-accent-rgb), 0.15);
    }
  }

  /* ── Captions ── */
  .lightbox-caption {
    color: #fff;
    text-align: center;
    padding: 1rem;
    font-size: 0.9rem;
    max-width: 600px;
  }

  /* Rich structured caption */
  .lightbox-caption.lightbox-caption--rich {
    max-width: 520px;
    text-align: left;
    padding: 1.25rem 0 0;
  }

  .lightbox-caption-header {
    display: flex;
    align-items: baseline;
    gap: 10px;
    margin-bottom: 8px;
  }

  .lightbox-caption-title {
    font-size: 1.25rem;
    font-weight: 600;
    color: #fff;
  }

  .lightbox-caption-year {
    font-size: 0.8rem;
    color: rgba(255, 255, 255, 0.45);
    font-family: 'JetBrains Mono', 'SF Mono', monospace;
  }

  .lightbox-caption-desc {
    font-size: 0.85rem;
    color: rgba(255, 255, 255, 0.7);
    line-height: 1.55;
    margin: 0 0 14px;
  }

  .lightbox-caption-tags {
    display: flex;
    flex-wrap: wrap;
    gap: 6px;
    margin-bottom: 14px;
  }

  .lightbox-tag {
    font-size: 11px;
    padding: 3px 10px;
    background: rgba(var(--lightbox-accent-rgb), 0.12);
    border: 1px solid rgba(var(--lightbox-accent-rgb), 0.25);
    border-radius: 12px;
    color: var(--lightbox-accent);
    font-family: 'JetBrains Mono', 'SF Mono', monospace;
    letter-spacing: 0.02em;
  }

  .lightbox-caption-link {
    font-size: 0.8rem;
    color: var(--lightbox-accent);
    text-decoration: none;
    transition: color 0.2s ease;
  }

  .lightbox-caption-link:hover {
    color: oklch(0.8 0.05 340);
    text-decoration: underline;
  }

  /* ── Controls ── */
  .lightbox-close {
    position: absolute;
    top: 20px;
    right: 30px;
    font-size: 48px;
    color: #fff;
    background: none;
    border: none;
    cursor: pointer;
    line-height: 1;
    transition: opacity 0.2s ease;
    z-index: 1;
  }

  .lightbox-close:hover {
    opacity: 0.7;
  }

  .lightbox-close:focus-visible {
    outline: 2px solid var(--lightbox-accent);
    outline-offset: 4px;
    border-radius: 4px;
  }

  .lightbox-prev,
  .lightbox-next {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    font-size: 64px;
    color: #fff;
    background: none;
    border: none;
    cursor: pointer;
    padding: 20px;
    transition: opacity 0.2s ease;
    z-index: 1;
  }

  .lightbox-prev { left: 20px; }
  .lightbox-next { right: 20px; }

  .lightbox-prev:hover,
  .lightbox-next:hover {
    opacity: 0.7;
  }

  .lightbox-prev:focus-visible,
  .lightbox-next:focus-visible {
    outline: 2px solid var(--lightbox-accent);
    outline-offset: 4px;
    border-radius: 4px;
  }

  /* ── Lock background scroll when lightbox is open ── */
  body.lightbox-open {
    overflow: hidden;
  }

  /* ── Hide fixed page UI when lightbox is open ── */
  body.lightbox-open .pdf-export-btn,
  body.lightbox-open .resume-theme-toggle,
  body.lightbox-open .back-link {
    opacity: 0 !important;
    pointer-events: none !important;
    transition: opacity 0.2s ease;
  }

  /* ── Counter ── */
  .lightbox-counter {
    position: absolute;
    bottom: 16px;
    left: 50%;
    transform: translateX(-50%);
    font-family: 'JetBrains Mono', 'SF Mono', monospace;
    font-size: 0.75rem;
    color: rgba(255, 255, 255, 0.4);
    letter-spacing: 0.05em;
  }

  /* ── Mobile ── */
  @media (max-width: 768px) {
    /* Swipe replaces arrow buttons on mobile */
    dialog#lightbox-overlay .lightbox-prev,
    dialog#lightbox-overlay .lightbox-next {
      display: none;
    }

    .lightbox-close {
      top: 10px;
      right: 15px;
      font-size: 36px;
      width: 48px;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .lightbox-content {
      padding: 1.5rem 1rem;
    }

    .lightbox-caption.lightbox-caption--rich {
      max-width: 90vw;
      padding: 1rem 0.5rem 0;
    }

    .lightbox-caption-title {
      font-size: 1.1rem;
    }

    .lightbox-caption-desc {
      font-size: 0.8rem;
    }
  }
</style>

<script>
  /**
   * Lightbox Controller
   *
   * Native <dialog> with @starting-style animations, View Transitions API
   * morphing, pointer-event swipe gestures, and proper View Transition cleanup.
   */
  (function() {
    let clickHandler: ((e: MouseEvent) => void) | null = null;
    let keydownHandler: ((e: KeyboardEvent) => void) | null = null;
    let initialized = false;

    function escapeHtml(s: string): string {
      return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;');
    }

    function initLightbox() {
      if (initialized) return;

      const overlay = document.getElementById('lightbox-overlay') as HTMLDialogElement | null;
      const lightboxImg = document.getElementById('lightbox-img') as HTMLImageElement;
      const caption = overlay?.querySelector('.lightbox-caption');
      const counter = overlay?.querySelector('.lightbox-counter');
      const closeBtn = overlay?.querySelector('.lightbox-close');
      const prevBtn = overlay?.querySelector('.lightbox-prev');
      const nextBtn = overlay?.querySelector('.lightbox-next');

      if (!overlay || !lightboxImg) return;
      initialized = true;

      // ── Gallery data ──
      interface GalleryImage {
        src: string;
        caption: string;
        title?: string;
        year?: string;
        description?: string;
        tags?: string[];
        link?: { url: string; label: string };
        invertInLightbox?: boolean;
        circular?: boolean;
      }

      interface Gallery {
        id: string;
        trigger: string;
        images: GalleryImage[];
      }

      let galleries: Gallery[] = [];
      const galleryDataEl = document.getElementById('gallery-data');
      if (galleryDataEl) {
        try {
          galleries = JSON.parse(galleryDataEl.textContent || '[]');
        } catch (e) {
          console.error('Failed to parse gallery data:', e);
        }
      }

      let currentGalleryImages: GalleryImage[] = [];
      let currentIndex = 0;
      let triggerElement: HTMLElement | null = null;

      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)');

      // ── Helpers ──
      function getFilename(path: string): string {
        return path.split('/').pop() || '';
      }

      function findGalleryForImage(src: string): { gallery: Gallery; startIndex: number } | undefined {
        const filename = getFilename(src).toLowerCase();
        for (const g of galleries) {
          const idx = g.images.findIndex(img => {
            const imgFilename = getFilename(img.src).toLowerCase();
            return filename === imgFilename || filename.includes(imgFilename) || imgFilename.includes(filename);
          });
          if (idx >= 0) return { gallery: g, startIndex: idx };
        }
        const match = galleries.find(g => g.trigger !== '__match_any_image__' && filename.includes(g.trigger.toLowerCase()));
        return match ? { gallery: match, startIndex: 0 } : undefined;
      }

      // ── Image display ──
      function showImage(index: number) {
        const item = currentGalleryImages[index];
        if (!item) return;

        lightboxImg.src = item.src;
        lightboxImg.alt = item.title || item.caption;

        if (item.invertInLightbox) {
          lightboxImg.classList.add('lightbox-img--invert');
        } else {
          lightboxImg.classList.remove('lightbox-img--invert');
        }

        if (item.circular) {
          lightboxImg.classList.add('lightbox-img--circular');
        } else {
          lightboxImg.classList.remove('lightbox-img--circular');
        }

        if (caption) {
          if (item.title) {
            let html = '<div class="lightbox-caption-header">';
            html += `<span class="lightbox-caption-title">${escapeHtml(item.title)}</span>`;
            if (item.year) html += `<span class="lightbox-caption-year">${escapeHtml(item.year)}</span>`;
            html += '</div>';
            if (item.description) {
              html += `<p class="lightbox-caption-desc">${escapeHtml(item.description)}</p>`;
            }
            if (item.tags && item.tags.length > 0) {
              html += '<div class="lightbox-caption-tags">';
              item.tags.forEach(tag => {
                html += `<span class="lightbox-tag">${escapeHtml(tag)}</span>`;
              });
              html += '</div>';
            }
            if (item.link) {
              html += `<a class="lightbox-caption-link" href="${escapeHtml(item.link.url)}" target="_blank" rel="noopener">${escapeHtml(item.link.label)} →</a>`;
            }
            caption.innerHTML = html;
            caption.classList.add('lightbox-caption--rich');
          } else {
            caption.textContent = item.caption;
            caption.classList.remove('lightbox-caption--rich');
          }
        }

        if (counter && currentGalleryImages.length > 1) {
          counter.textContent = `${index + 1} / ${currentGalleryImages.length}`;
        } else if (counter) {
          counter.textContent = '';
        }
      }

      // ── Open / Close ──
      function openLightbox() {
        overlay.showModal();
        document.body.classList.add('lightbox-open');
      }

      function closeLightbox() {
        overlay.close();
      }

      // Cleanup on any close (Escape, button, backdrop, swipe)
      overlay.addEventListener('close', () => {
        // During View Transition morph, transition.finished handles cleanup
        if (overlay.hasAttribute('data-vt-close')) return;
        document.body.classList.remove('lightbox-open');
        if (triggerElement) {
          triggerElement.focus();
          triggerElement = null;
        }
      });

      // ── View Transitions morphing ──
      function canMorph(): boolean {
        return !!(document as any).startViewTransition && !prefersReducedMotion.matches;
      }

      function openWithMorph(triggerImg: HTMLElement) {
        if (!canMorph()) {
          openLightbox();
          return;
        }

        // Suppress @starting-style entry animation — View Transition handles the visual
        overlay.setAttribute('data-vt-open', '');
        triggerImg.style.viewTransitionName = 'lightbox-hero';
        const transition = (document as any).startViewTransition(() => {
          triggerImg.style.viewTransitionName = '';
          lightboxImg.style.viewTransitionName = 'lightbox-hero';
          openLightbox();
        });

        transition.finished.then(() => {
          lightboxImg.style.viewTransitionName = '';
          overlay.removeAttribute('data-vt-open');
        }).catch(() => {
          lightboxImg.style.viewTransitionName = '';
          overlay.removeAttribute('data-vt-open');
        });
      }

      function closeWithMorph() {
        if (!canMorph() || !triggerElement) {
          closeLightbox();
          return;
        }

        const trigger = triggerElement;
        const triggerImg = trigger.querySelector('img') || trigger;

        // Skip dialog exit animation—let View Transition handle the visual
        overlay.setAttribute('data-vt-close', '');
        lightboxImg.style.viewTransitionName = 'lightbox-hero';

        const transition = (document as any).startViewTransition(() => {
          lightboxImg.style.viewTransitionName = '';
          (triggerImg as HTMLElement).style.viewTransitionName = 'lightbox-hero';
          overlay.close();
        });

        transition.finished.then(() => {
          (triggerImg as HTMLElement).style.viewTransitionName = '';
          document.body.classList.remove('lightbox-open');
          overlay.removeAttribute('data-vt-close');
          trigger.focus();
          triggerElement = null;
        }).catch(() => {
          (triggerImg as HTMLElement).style.viewTransitionName = '';
          document.body.classList.remove('lightbox-open');
          overlay.removeAttribute('data-vt-close');
        });
      }

      // ── Navigation ──
      function showPrev() {
        currentIndex = (currentIndex - 1 + currentGalleryImages.length) % currentGalleryImages.length;
        showImage(currentIndex);
      }

      function showNext() {
        currentIndex = (currentIndex + 1) % currentGalleryImages.length;
        showImage(currentIndex);
      }

      // ── Swipe gestures (Pointer Events) ──
      const SWIPE_THRESHOLD = 50;
      const SWIPE_TIMEOUT = 300;
      let pointerStartX = 0, pointerStartY = 0, pointerStartTime = 0;

      overlay.addEventListener('pointerdown', (e) => {
        // Don't capture pointer on interactive controls — capture prevents
        // their click events from firing (pointerup redirects to overlay)
        if ((e.target as HTMLElement).closest('button, a')) return;
        pointerStartX = e.clientX;
        pointerStartY = e.clientY;
        pointerStartTime = Date.now();
        (e.currentTarget as HTMLElement).setPointerCapture(e.pointerId);
      });

      overlay.addEventListener('pointerup', (e) => {
        const dx = e.clientX - pointerStartX;
        const dy = e.clientY - pointerStartY;
        if (Date.now() - pointerStartTime > SWIPE_TIMEOUT) return;
        if (Math.abs(dx) < SWIPE_THRESHOLD && Math.abs(dy) < SWIPE_THRESHOLD) return;

        if (Math.abs(dx) > Math.abs(dy)) {
          dx > 0 ? showPrev() : showNext();
        } else if (dy > 0 && dy > SWIPE_THRESHOLD * 1.5) {
          closeWithMorph();
        }
      });

      // ── Light dismiss (fallback for browsers without closedby="any") ──
      overlay.addEventListener('click', (e) => {
        if (e.target === overlay) closeWithMorph();
      });

      // ── Event delegation for trigger clicks ──
      clickHandler = (e: MouseEvent) => {
        const target = (e.target as HTMLElement).closest('[data-lightbox]') as HTMLElement;
        if (!target) return;

        e.preventDefault();

        const imgEl = target.tagName === 'IMG' ? target as HTMLImageElement : target.querySelector('img');
        const src = imgEl?.src || target.dataset.lightboxSrc || '';

        // Store trigger for focus return + View Transition morph
        triggerElement = target;

        const result = findGalleryForImage(src);
        if (result && result.gallery.images.length > 0) {
          currentGalleryImages = result.gallery.images;
          currentIndex = result.startIndex;
        } else {
          const alt = (imgEl as HTMLImageElement)?.alt || '';
          currentGalleryImages = [{ src, caption: alt }];
          currentIndex = 0;
        }

        showImage(currentIndex);
        openWithMorph(imgEl || target);
      };

      // ── Keyboard (Arrow keys only—<dialog> handles Escape natively) ──
      keydownHandler = (e: KeyboardEvent) => {
        if (!overlay.open) return;
        switch (e.key) {
          case 'ArrowLeft': showPrev(); break;
          case 'ArrowRight': showNext(); break;
        }
      };

      document.addEventListener('click', clickHandler);
      document.addEventListener('keydown', keydownHandler);

      closeBtn?.addEventListener('click', () => closeWithMorph());
      prevBtn?.addEventListener('click', showPrev);
      nextBtn?.addEventListener('click', showNext);
    }

    function cleanupLightbox() {
      if (clickHandler) {
        document.removeEventListener('click', clickHandler);
        clickHandler = null;
      }
      if (keydownHandler) {
        document.removeEventListener('keydown', keydownHandler);
        keydownHandler = null;
      }
      initialized = false;
    }

    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initLightbox);
    } else {
      initLightbox();
    }

    document.addEventListener('astro:before-swap', cleanupLightbox);
    document.addEventListener('astro:after-swap', initLightbox);
  })();
</script>
