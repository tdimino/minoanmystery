---
/**
 * The Labyrinth - Soul Conversation Page
 *
 * Full chat interface for extended conversations with the Oracle.
 * Displays conversation history and allows continued dialogue.
 */
import BaseLayout from '../layouts/BaseLayout.astro';
import Header from '../components/Header.astro';
---

<BaseLayout
  title="The Labyrinth - Consult with Kothar"
  description="Enter the labyrinth and converse with Kothar, the divine craftsman. An A.I. soul awakened from ash and pumice. What secrets does he hold?"
  image="/images/og/labyrinth.png"
>
  <!-- Divine Feminine Background - manifests when goddess is invoked -->
  <div id="goddess-background" class="soul-bg goddess-bg" aria-hidden="true">
    <div class="soul-vignette goddess-vignette"></div>
  </div>

  <!-- Vision Background - AI-generated images from Kothar -->
  <div id="vision-background" class="soul-bg vision-bg" aria-hidden="true">
    <div class="soul-vignette vision-vignette"></div>
  </div>

  <!-- Tarot Background - Generated Minoan tarot cards -->
  <div id="tarot-background" class="soul-bg tarot-bg" aria-hidden="true">
    <div class="soul-vignette tarot-vignette"></div>
  </div>

  <Header />
  <main class="labyrinth-page">
    <header class="labyrinth-header">
      <div class="labyrinth-title">
        <h1>Consult with Kothar</h1>
        <p>The divine craftsman of this digital labyrinth.</p>
      </div>
    </header>

    <!-- Soul State Indicator -->
    <div class="soul-state-indicator" id="soul-state-indicator">
      <span class="soul-state-dot" id="soul-state-dot"></span>
      <span class="soul-state-text" id="soul-state-text">Kothar is pondering...</span>
    </div>

    <div class="labyrinth-container">
      <div id="conversation-history" class="conversation-history">
        <div class="conversation-empty" id="conversation-empty">
          <div class="empty-icon">
            <img src="/images/avatars/minoan-avatar.webp" alt="Minoan" class="empty-avatar" />
          </div>
          <p>Kothar awaits your first question.</p>
          <p class="empty-hint">Type below or use Cmd+K to begin.</p>
        </div>
      </div>

      <!-- Archive Search Indicator - shows during RAG retrieval -->
      <div id="archive-indicator" class="archive-indicator" aria-live="polite">
        <span class="archive-icon">◈</span>
        <span class="archive-text">Kothar is consulting his archives</span>
        <span class="archive-dots"><span>.</span><span>.</span><span>.</span></span>
      </div>

      <form id="labyrinth-form" class="labyrinth-form">
        <!-- Hidden file input for image selection -->
        <input
          type="file"
          id="image-input"
          class="image-input-hidden"
          accept="image/png,image/jpeg,image/webp"
          aria-hidden="true"
        />

        <!-- Attachment preview bar (shown when image pending) -->
        <div id="attachment-preview" class="attachment-preview-bar" style="display: none;">
          <img id="attachment-thumbnail" class="attachment-thumbnail" src="" alt="Attachment preview" />
          <button type="button" id="attachment-dismiss" class="attachment-dismiss" aria-label="Remove attachment">
            <svg xmlns="http://www.w3.org/2000/svg" width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <line x1="18" y1="6" x2="6" y2="18"></line>
              <line x1="6" y1="6" x2="18" y2="18"></line>
            </svg>
          </button>
        </div>

        <div class="form-input-wrapper">
          <input
            type="text"
            id="labyrinth-input"
            class="labyrinth-input"
            placeholder="Ask Kothar..."
            autocomplete="off"
            spellcheck="false"
          />
          <!-- Attach image button -->
          <button type="button" id="attach-button" class="attach-button" aria-label="Attach image">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <path d="M21.44 11.05l-9.19 9.19a6 6 0 0 1-8.49-8.49l9.19-9.19a4 4 0 0 1 5.66 5.66l-9.2 9.19a2 2 0 0 1-2.83-2.83l8.49-8.48"></path>
            </svg>
          </button>
          <button type="submit" class="labyrinth-submit" aria-label="Send message">
            <svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
              <line x1="22" y1="2" x2="11" y2="13"></line>
              <polygon points="22 2 15 22 11 13 2 9 22 2"></polygon>
            </svg>
          </button>
        </div>
        <div class="form-hints">
          <kbd>Enter</kbd> to send
          <span class="hint-separator">•</span>
          <kbd>Cmd+K</kbd> for commands
          <span class="hint-separator">•</span>
          <span class="hint-paste">Paste image</span>
        </div>
      </form>

    </div>

    <!-- Voice input button removed per user request -->
  </main>
</BaseLayout>

<style>
  /* ─────────────────────────────────────────────────────────────
     Soul Background Base Class
     Shared styles for all ethereal background manifestations
     ───────────────────────────────────────────────────────────── */

  .soul-bg {
    position: fixed;
    inset: 0;
    z-index: 0;
    pointer-events: none;
    opacity: 0;
    transition: opacity 2.5s cubic-bezier(0.4, 0, 0.2, 1);
    overflow: hidden;
  }

  .soul-bg.active {
    opacity: 1;
  }

  /* Shared vignette base */
  .soul-vignette {
    position: absolute;
    inset: 0;
  }

  /* ─────────────────────────────────────────────────────────────
     Divine Feminine Background
     Ethereal manifestation when goddess terms are invoked
     ───────────────────────────────────────────────────────────── */

  .goddess-bg::before {
    content: '';
    position: absolute;
    inset: 0;
    background-image: url('/images/soul/potnia-theron-transparent.png');
    background-size: contain;
    background-position: center;
    background-repeat: no-repeat;
    opacity: 0.12;
    filter: sepia(0.3) saturate(0.8);
    animation: goddess-breathe 12s ease-in-out infinite paused;
  }

  .goddess-bg.active::before {
    animation-play-state: running;
  }

  /* Goddess vignette specifics */
  .goddess-vignette {
    background: radial-gradient(
      ellipse at center,
      transparent 20%,
      rgba(var(--color-background-rgb, 255, 255, 255), 0.7) 70%,
      var(--color-background) 100%
    );
  }

  :global([data-theme='dark']) .goddess-vignette {
    background: radial-gradient(
      ellipse at center,
      transparent 20%,
      rgba(13, 13, 13, 0.7) 70%,
      #0d0d0d 100%
    );
  }

  :global([data-theme='dark']) .goddess-bg::before {
    filter: sepia(0.2) saturate(0.6) brightness(0.9);
    opacity: 0.08;
  }

  @keyframes goddess-breathe {
    0%, 100% {
      transform: scale(1) translateY(0);
      opacity: 0.10;
    }
    50% {
      transform: scale(1.02) translateY(-1%);
      opacity: 0.14;
    }
  }

  /* ─────────────────────────────────────────────────────────────
     Vision Background (AI-Generated)
     Ethereal manifestation of Kothar's visions
     ───────────────────────────────────────────────────────────── */

  .vision-bg::before {
    content: '';
    position: absolute;
    inset: 0;
    background-size: cover;
    background-position: center;
    background-repeat: no-repeat;
    opacity: 0.15;
    filter: sepia(0.2) saturate(0.9);
    animation: vision-breathe 15s ease-in-out infinite paused;
  }

  .vision-bg.active::before {
    animation-play-state: running;
  }

  /* Vision vignette specifics */
  .vision-vignette {
    background: radial-gradient(
      ellipse at center,
      transparent 30%,
      rgba(var(--color-background-rgb, 255, 255, 255), 0.6) 65%,
      var(--color-background) 100%
    );
  }

  :global([data-theme='dark']) .vision-vignette {
    background: radial-gradient(
      ellipse at center,
      transparent 30%,
      rgba(13, 13, 13, 0.6) 65%,
      #0d0d0d 100%
    );
  }

  :global([data-theme='dark']) .vision-bg::before {
    filter: sepia(0.15) saturate(0.7) brightness(0.85);
    opacity: 0.12;
  }

  @keyframes vision-breathe {
    0%, 100% {
      transform: scale(1) translateY(0);
      opacity: 0.12;
    }
    50% {
      transform: scale(1.015) translateY(-0.5%);
      opacity: 0.16;
    }
  }

  /* ─────────────────────────────────────────────────────────────
     Tarot Background (Generated Minoan Tarot Cards)
     Ethereal manifestation of the tarot every 10 turns
     ───────────────────────────────────────────────────────────── */

  /* Tarot vignette specifics - softer, synchronized with card breathing */
  .tarot-vignette {
    background: radial-gradient(
      ellipse 130% 130% at center,
      transparent 10%,
      rgba(var(--color-background-rgb, 255, 255, 255), 0.3) 35%,
      rgba(var(--color-background-rgb, 255, 255, 255), 0.65) 55%,
      var(--color-background) 80%
    );
    z-index: 3;
    animation: tarot-vignette-pulse 18s ease-in-out infinite;
  }

  :global([data-theme='dark']) .tarot-vignette {
    background: radial-gradient(
      ellipse 130% 130% at center,
      transparent 10%,
      rgba(13, 13, 13, 0.3) 35%,
      rgba(13, 13, 13, 0.65) 55%,
      #0d0d0d 80%
    );
  }

  /* Card name handled via CSS class below */
  .tarot-card-name-old {
    display: none;
    z-index: 2;
    font-family: var(--font-display, 'Thicccboi', sans-serif);
    font-size: clamp(11px, 1.5vw, 14px);
    font-weight: 400;
    letter-spacing: 0.25em;
    text-transform: uppercase;
    color: var(--color-primary);
    opacity: 0.35;
    filter: blur(0.3px);
    text-shadow: 0 0 30px rgba(var(--color-background-rgb, 255, 255, 255), 0.6);
    animation: tarot-name-pulse 8s ease-in-out infinite;
  }

  :global([data-theme='dark']) .tarot-card-name {
    text-shadow: 0 0 30px rgba(0, 0, 0, 0.6);
    opacity: 0.3;
  }

  @keyframes tarot-name-pulse {
    0%, 100% {
      opacity: 0.25;
      filter: blur(0.4px);
    }
    50% {
      opacity: 0.4;
      filter: blur(0.2px);
    }
  }

  /* ═══════════════════════════════════════════════════════════════════════════
     WORLD-CLASS TAROT ANIMATIONS (9-10/10 Quality)
     Three-stage entrance, polyrhythmic halos, exit dissolve
     ═══════════════════════════════════════════════════════════════════════════ */

  /* Stage 1: Ethereal glow precedes card (0-1s) */
  @keyframes tarot-entrance-glow {
    0% {
      opacity: 0;
      filter: blur(40px);
      transform: scale(1.3);
    }
    100% {
      opacity: 0.4;
      filter: blur(20px);
      transform: scale(1.1);
    }
  }

  /* Stage 2: Card materializes through glow (0.8-2s) */
  @keyframes tarot-entrance-materialize {
    0% {
      opacity: 0;
      filter: blur(8px) brightness(1.5);
      transform: scale(1.08);
    }
    60% {
      opacity: 0.2;
      filter: blur(2px) brightness(1.2);
    }
    100% {
      opacity: 0.25;
      filter: sepia(0.03) saturate(0.95);
      transform: scale(1);
    }
  }

  /* Stage 3: Card settles into breathing (2s+) */
  @keyframes tarot-breathe {
    0%, 100% {
      transform: scale(1);
      opacity: 0.22;
    }
    50% {
      transform: scale(1.015);
      opacity: 0.28;
    }
  }

  /* Synchronized vignette pulse */
  @keyframes tarot-vignette-pulse {
    0%, 100% {
      opacity: 0.85;
    }
    50% {
      opacity: 0.75;
    }
  }

  /* Polyrhythmic Inner Halo: 18s cycle (matches card breathing) */
  @keyframes tarot-halo-inner {
    0%, 100% {
      box-shadow:
        0 0 50px 12px rgba(150, 106, 133, 0.1),
        inset 0 0 35px 8px rgba(150, 106, 133, 0.04);
      transform: translate(-50%, -50%) scale(1);
    }
    50% {
      box-shadow:
        0 0 65px 18px rgba(150, 106, 133, 0.14),
        inset 0 0 45px 12px rgba(150, 106, 133, 0.06);
      transform: translate(-50%, -50%) scale(1.008);
    }
  }

  /* Polyrhythmic Outer Halo: 23s cycle (prime number avoids sync) */
  @keyframes tarot-halo-outer {
    0%, 100% {
      box-shadow:
        0 0 100px 40px rgba(150, 106, 133, 0.05),
        0 0 160px 70px rgba(150, 106, 133, 0.025);
      filter: blur(4px);
      opacity: 1;
    }
    50% {
      box-shadow:
        0 0 130px 55px rgba(150, 106, 133, 0.08),
        0 0 200px 90px rgba(150, 106, 133, 0.04);
      filter: blur(6px);
      opacity: 1;
    }
  }

  /* Legacy halo pulse (fallback) */
  @keyframes tarot-halo-pulse {
    0%, 100% {
      box-shadow:
        0 0 60px 15px rgba(150, 106, 133, 0.08),
        0 0 100px 30px rgba(150, 106, 133, 0.05),
        0 0 140px 50px rgba(150, 106, 133, 0.025),
        inset 0 0 40px 10px rgba(150, 106, 133, 0.03);
      transform: translate(-50%, -50%) scale(1);
      filter: blur(2px);
    }
    50% {
      box-shadow:
        0 0 70px 20px rgba(150, 106, 133, 0.12),
        0 0 120px 40px rgba(150, 106, 133, 0.07),
        0 0 160px 60px rgba(150, 106, 133, 0.035),
        inset 0 0 50px 15px rgba(150, 106, 133, 0.05);
      transform: translate(-50%, -50%) scale(1.01);
      filter: blur(3px);
    }
  }

  /* Entrance halo fade-in */
  @keyframes tarot-halo-entrance {
    0% {
      opacity: 0;
      transform: translate(-50%, -50%) scale(0.95);
    }
    100% {
      opacity: 1;
      transform: translate(-50%, -50%) scale(1);
    }
  }

  /* Exit animation - card dissolves gracefully */
  @keyframes tarot-exit {
    0% {
      opacity: 1;
      filter: blur(0) sepia(0.03) saturate(0.95);
    }
    70% {
      opacity: 0.6;
      filter: blur(3px) sepia(0.1) saturate(0.8);
    }
    100% {
      opacity: 0;
      filter: blur(12px) sepia(0.2) saturate(0.6);
      transform: scale(1.05);
    }
  }

  /* Exit for halos */
  @keyframes tarot-halo-exit {
    0% {
      opacity: 1;
    }
    100% {
      opacity: 0;
      filter: blur(20px);
    }
  }

  /* Atmospheric noise grain */
  @keyframes tarot-noise {
    0%, 100% { transform: translate(0, 0); }
    10% { transform: translate(-1%, -1%); }
    20% { transform: translate(1%, 0%); }
    30% { transform: translate(0%, 1%); }
    40% { transform: translate(-1%, 1%); }
    50% { transform: translate(1%, -1%); }
    60% { transform: translate(-1%, 0%); }
    70% { transform: translate(0%, -1%); }
    80% { transform: translate(1%, 1%); }
    90% { transform: translate(-1%, -1%); }
  }

  /* Floating gold dust particle animation */
  @keyframes tarot-particle-float {
    0%, 100% {
      transform: translate(0, 0) scale(1);
      opacity: 0.2;
    }
    50% {
      transform: translate(var(--drift-x, 20px), var(--drift-y, -30px)) scale(1.5);
      opacity: 0.5;
    }
  }

  /* Particle entrance stagger */
  @keyframes tarot-particle-entrance {
    0% {
      opacity: 0;
      transform: scale(0);
    }
    100% {
      opacity: var(--particle-opacity, 0.3);
      transform: scale(1);
    }
  }

  /* Card name typography - incised Roman capitals */
  .tarot-card-name {
    position: absolute;
    bottom: 12%;
    left: 50%;
    transform: translateX(-50%);
    font-family: 'Cormorant Garamond', 'Times New Roman', serif;
    font-size: clamp(0.65rem, 1.2vw, 0.9rem);
    font-weight: 600;
    letter-spacing: 0.35em;
    text-transform: uppercase;
    color: rgba(150, 106, 133, 0);  /* Start invisible for entrance */
    text-shadow:
      0 1px 0 rgba(255, 255, 255, 0.03),
      0 -1px 0 rgba(0, 0, 0, 0.15),
      0 0 25px rgba(150, 106, 133, 0.3);  /* Soft glow */
    white-space: nowrap;
    z-index: 10;
    opacity: 0;
    /* Name fades in after card materializes */
    animation:
      tarot-name-reveal 2s ease-out 2.5s forwards,
      tarot-name-breathe 18s ease-in-out 4.5s infinite;
  }

  /* Name entrance reveal */
  @keyframes tarot-name-reveal {
    0% {
      opacity: 0;
      letter-spacing: 0.5em;
      filter: blur(4px);
      color: rgba(150, 106, 133, 0);
    }
    100% {
      opacity: 1;
      letter-spacing: 0.35em;
      filter: blur(0);
      color: rgba(150, 106, 133, 0.5);
    }
  }

  /* Subtle name breathing (after reveal) */
  @keyframes tarot-name-breathe {
    0%, 100% {
      opacity: 0.5;
      text-shadow:
        0 1px 0 rgba(255, 255, 255, 0.03),
        0 -1px 0 rgba(0, 0, 0, 0.15),
        0 0 25px rgba(150, 106, 133, 0.2);
    }
    50% {
      opacity: 0.65;
      text-shadow:
        0 1px 0 rgba(255, 255, 255, 0.04),
        0 -1px 0 rgba(0, 0, 0, 0.18),
        0 0 35px rgba(150, 106, 133, 0.35);
    }
  }

  /* Dark mode name adjustments */
  :global([data-theme='dark']) .tarot-card-name {
    text-shadow:
      0 1px 0 rgba(255, 255, 255, 0.02),
      0 -1px 0 rgba(0, 0, 0, 0.25),
      0 0 30px rgba(201, 160, 184, 0.25);
  }

  /* Mobile: larger card, adjusted positioning */
  @media (max-width: 768px) {
    .tarot-card-name {
      bottom: 8%;
      font-size: 0.7rem;
      letter-spacing: 0.2em;
    }
  }

  /* ─────────────────────────────────────────────────────────────
     Tarot Particles - floating gold dust motes
     ───────────────────────────────────────────────────────────── */

  .tarot-particles {
    position: absolute;
    inset: 0;
    pointer-events: none;
    overflow: hidden;
    z-index: 5;
    opacity: 0;
    transition: opacity 1s ease-out 3s;
  }

  .tarot-bg.active .tarot-particles {
    opacity: 1;
  }

  .tarot-particle {
    position: absolute;
    width: 2px;
    height: 2px;
    background: rgba(212, 175, 55, 0.4);  /* Gold dust */
    border-radius: 50%;
    opacity: 0;
    animation:
      tarot-particle-entrance 0.8s ease-out forwards,
      tarot-particle-float var(--duration, 8s) ease-in-out infinite;
    animation-delay: var(--delay, 0s), calc(var(--delay, 0s) + 0.8s);
  }

  /* Touch glow response - mobile feedback */
  .tarot-bg.touched .tarot-halo-inner {
    box-shadow:
      0 0 80px 25px rgba(212, 175, 55, 0.15),
      inset 0 0 50px 15px rgba(212, 175, 55, 0.05);
    transition: box-shadow 0.3s ease-out;
  }

  /* Exit state for all layers */
  .tarot-bg.exiting .tarot-image-layer {
    animation: tarot-exit 2s ease-in forwards !important;
  }

  .tarot-bg.exiting .tarot-halo-inner,
  .tarot-bg.exiting .tarot-halo-outer {
    animation: tarot-halo-exit 2s ease-in forwards !important;
  }

  .tarot-bg.exiting .tarot-particles {
    opacity: 0;
    transition: opacity 1.5s ease-in;
  }

  .tarot-bg.exiting .tarot-card-name {
    animation: tarot-exit 1.5s ease-in forwards !important;
  }

  /* GPU optimization layers */
  .tarot-image-layer,
  .tarot-halo-inner,
  .tarot-halo-outer,
  .tarot-particles,
  .tarot-dof-layer,
  .tarot-chromatic,
  .tarot-noise {
    will-change: transform, opacity;
    transform: translateZ(0);
  }

  /* Remove will-change after entrance settles (via JS class) */
  .tarot-bg.settled .tarot-image-layer,
  .tarot-bg.settled .tarot-halo-inner,
  .tarot-bg.settled .tarot-halo-outer,
  .tarot-bg.settled .tarot-particles,
  .tarot-bg.settled .tarot-dof-layer,
  .tarot-bg.settled .tarot-chromatic,
  .tarot-bg.settled .tarot-noise {
    will-change: auto;
  }

  /* Reduced motion support */
  @media (prefers-reduced-motion: reduce) {
    .tarot-image-layer {
      animation: none !important;
      opacity: 0.25;
    }
    .tarot-halo-inner,
    .tarot-halo-outer {
      animation: none !important;
    }
    .tarot-particle {
      animation: none !important;
      display: none;
    }
    .tarot-card-name {
      animation: none !important;
      opacity: 0.5;
      color: rgba(150, 106, 133, 0.5);
    }
    .tarot-noise {
      animation: none !important;
    }
  }

  /* ─────────────────────────────────────────────────────────────
     Archive Search Indicator
     Ancient knowledge being consulted
     ───────────────────────────────────────────────────────────── */

  .archive-indicator {
    display: none;
    align-items: center;
    gap: 0.5rem;
    padding: 0.875rem 1.25rem;
    margin: 0 0 0.75rem 0;
    background: linear-gradient(
      135deg,
      rgba(150, 106, 133, 0.08) 0%,
      rgba(150, 106, 133, 0.04) 100%
    );
    border-left: 2px solid var(--color-primary);
    border-radius: 0 12px 12px 0;
    font-size: 14px;
    font-style: italic;
    color: var(--color-text-muted);
    letter-spacing: 0.01em;
    backdrop-filter: blur(4px);
  }

  .archive-indicator.active {
    display: flex;
    animation: archive-reveal 0.4s cubic-bezier(0.4, 0, 0.2, 1);
  }

  @keyframes archive-reveal {
    from {
      opacity: 0;
      transform: translateX(-8px);
    }
    to {
      opacity: 1;
      transform: translateX(0);
    }
  }

  .archive-icon {
    color: var(--color-primary);
    font-size: 16px;
    animation: archive-icon-pulse 2s ease-in-out infinite;
  }

  @keyframes archive-icon-pulse {
    0%, 100% {
      opacity: 0.6;
      transform: scale(1);
    }
    50% {
      opacity: 1;
      transform: scale(1.1);
    }
  }

  .archive-text {
    flex: 1;
  }

  .archive-dots {
    display: flex;
    gap: 1px;
  }

  .archive-dots span {
    opacity: 0.3;
    animation: archive-dot 1.4s ease-in-out infinite;
  }

  .archive-dots span:nth-child(1) { animation-delay: 0s; }
  .archive-dots span:nth-child(2) { animation-delay: 0.2s; }
  .archive-dots span:nth-child(3) { animation-delay: 0.4s; }

  @keyframes archive-dot {
    0%, 80%, 100% {
      opacity: 0.3;
      transform: translateY(0);
    }
    40% {
      opacity: 1;
      transform: translateY(-2px);
    }
  }

  :global([data-theme='dark']) .archive-indicator {
    background: linear-gradient(
      135deg,
      rgba(201, 160, 184, 0.1) 0%,
      rgba(201, 160, 184, 0.04) 100%
    );
    border-left-color: var(--color-primary);
  }

  /* ─────────────────────────────────────────────────────────────
     Page Layout
     ───────────────────────────────────────────────────────────── */

  .labyrinth-page {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
    position: relative;
    z-index: 1;
  }

  .labyrinth-header {
    display: flex;
    align-items: center;
    justify-content: center;
    padding: 12px 48px;
    border-bottom: 1px solid var(--color-border);
    background: var(--color-background);
    position: relative;
  }

  .labyrinth-header-inner {
    display: flex;
    align-items: center;
    justify-content: center;
    width: 100%;
  }

  .labyrinth-title {
    text-align: center;
  }

  .labyrinth-menu-container {
    position: absolute;
    right: 48px;
  }

  .labyrinth-title h1 {
    font-size: 18px;
    font-weight: 500;
    margin: 0;
    color: var(--color-text);
  }

  .labyrinth-title p {
    font-size: 13px;
    color: var(--color-text-muted);
    margin: 2px 0 0;
  }

  /* Soul State Indicator */
  .soul-state-indicator {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    padding: 8px 16px;
    opacity: 0.5;
    transition: opacity 0.3s ease;
  }

  .soul-state-indicator:hover {
    opacity: 0.7;
  }

  .soul-state-dot {
    width: 8px;
    height: 8px;
    border-radius: 50%;
    background-color: var(--color-primary);
    animation: soul-pulse 2s ease-in-out infinite;
  }

  .soul-state-text {
    font-size: 12px;
    font-style: italic;
    color: var(--color-text-muted);
    letter-spacing: 0.02em;
  }

  @keyframes soul-pulse {
    0%, 100% {
      opacity: 0.4;
      transform: scale(1);
    }
    50% {
      opacity: 1;
      transform: scale(1.1);
    }
  }

  /* State-specific dot colors */
  .soul-state-dot[data-state="greeting"] {
    background-color: #966a85; /* Tyrian purple */
  }
  .soul-state-dot[data-state="curious"] {
    background-color: #d4af37; /* Gold */
  }
  .soul-state-dot[data-state="engaged"] {
    background-color: #7b5e99; /* Deep purple */
  }
  .soul-state-dot[data-state="ready"] {
    background-color: #5a9a6e; /* Sage green */
  }
  .soul-state-dot[data-state="returning"] {
    background-color: #5b8cb8; /* Mediterranean blue */
  }
  .soul-state-dot[data-state="dormant"] {
    background-color: #888888; /* Gray */
    animation: soul-pulse 4s ease-in-out infinite; /* Slower pulse */
  }
  .soul-state-dot[data-state="exiting"] {
    background-color: #b89ac9; /* Soft lavender */
  }

  /* Options Menu */
  .labyrinth-menu-container {
    position: relative;
  }

  .labyrinth-menu-trigger {
    background: none;
    border: none;
    color: var(--color-text-muted);
    cursor: pointer;
    padding: 8px;
    border-radius: 8px;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
    min-width: 44px;
    min-height: 44px;
  }

  .labyrinth-menu-trigger:hover {
    background: var(--color-background-alt);
    color: var(--color-text);
  }

  .labyrinth-menu {
    position: absolute;
    top: calc(100% + 8px);
    right: 0;
    background: var(--color-background);
    border: 1px solid var(--color-border);
    border-radius: 12px;
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.15);
    min-width: 200px;
    padding: 6px;
    opacity: 0;
    visibility: hidden;
    transform: translateY(-8px) scale(0.95);
    transition: all 0.2s ease;
    z-index: 100;
  }

  .labyrinth-menu.is-open {
    opacity: 1;
    visibility: visible;
    transform: translateY(0) scale(1);
  }

  .labyrinth-menu-item {
    display: flex;
    align-items: center;
    gap: 12px;
    width: 100%;
    padding: 12px 14px;
    background: none;
    border: none;
    border-radius: 8px;
    color: var(--color-text);
    font-size: 14px;
    font-family: var(--font-body);
    cursor: pointer;
    transition: background 0.15s ease;
    text-align: left;
  }

  .labyrinth-menu-item:hover {
    background: var(--color-background-alt);
  }

  .labyrinth-menu-item svg {
    color: var(--color-text-muted);
    flex-shrink: 0;
  }

  .labyrinth-menu-item--danger {
    color: #dc3545;
  }

  .labyrinth-menu-item--danger svg {
    color: #dc3545;
  }

  .labyrinth-menu-item--danger:hover {
    background: rgba(220, 53, 69, 0.1);
  }

  .labyrinth-menu-divider {
    height: 1px;
    background: var(--color-border);
    margin: 6px 0;
  }

  /* Dark mode menu adjustments */
  :global([data-theme='dark']) .labyrinth-menu {
    box-shadow: 0 10px 40px rgba(0, 0, 0, 0.4);
  }

  .labyrinth-container {
    flex: 1;
    display: flex;
    flex-direction: column;
    max-width: 800px;
    margin: 0 auto;
    width: 100%;
    padding: 0 48px;
  }

  .conversation-history {
    flex: 1;
    padding-top: 32px;
    padding-bottom: 16px;
    overflow-y: auto;
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .conversation-empty {
    flex: 1;
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
    text-align: center;
    color: var(--color-text-muted);
    padding: 24px;
  }

  .empty-icon {
    margin-bottom: 16px;
  }

  .empty-avatar {
    width: 64px;
    height: 64px;
    border-radius: 50%;
    object-fit: cover;
    opacity: 0.5;
  }

  .empty-hint {
    font-size: 13px;
    opacity: 0.7;
    margin-top: 8px;
  }

  /* Message bubbles */
  :global(.message) {
    display: flex;
    gap: 12px;
    max-width: 85%;
  }

  :global(.message-user) {
    align-self: flex-end;
    flex-direction: row-reverse;
  }

  :global(.message-assistant) {
    align-self: flex-start;
  }

  :global(.message-avatar) {
    width: 36px;
    height: 36px;
    border-radius: 50%;
    display: flex;
    align-items: center;
    justify-content: center;
    flex-shrink: 0;
    overflow: hidden;
  }

  :global(.message-user .message-avatar) {
    background: var(--color-primary);
    color: white;
  }

  :global(.message-assistant .message-avatar) {
    background: transparent;
    overflow: hidden;
  }

  :global(.minoan-avatar-img) {
    width: 100%;
    height: 100%;
    object-fit: cover;
    border-radius: 50%;
  }

  :global(.message-content) {
    padding: 12px 16px;
    border-radius: 16px;
    font-size: 15px;
    line-height: 1.5;
  }

  :global(.message-user .message-content) {
    background: var(--color-primary);
    color: white;
    border-bottom-right-radius: 4px;
  }

  /* Richer Tyrian purple for dark mode bubbles */
  :global([data-theme="dark"] .message-user .message-content) {
    background: #6d4463;
  }

  :global([data-theme="dark"] .message-user .message-avatar) {
    background: #6d4463;
  }

  :global(.message-assistant .message-content) {
    background: var(--color-background-alt);
    color: var(--color-text);
    border-bottom-left-radius: 4px;
  }

  :global(.message-meta) {
    font-size: 11px;
    color: var(--color-text-muted);
    margin-top: 4px;
    opacity: 0.7;
  }

  /* Loading state */
  :global(.message-loading .message-content) {
    display: flex;
    gap: 4px;
    padding: 16px 20px;
  }

  :global(.loading-dot) {
    width: 8px;
    height: 8px;
    background: var(--color-primary);
    border-radius: 50%;
    opacity: 0.3;
    animation: loading-pulse 1.4s ease-in-out infinite;
  }

  :global(.loading-dot:nth-child(1)) { animation-delay: 0s; }
  :global(.loading-dot:nth-child(2)) { animation-delay: 0.2s; }
  :global(.loading-dot:nth-child(3)) { animation-delay: 0.4s; }

  @keyframes loading-pulse {
    0%, 60%, 100% { opacity: 0.3; transform: scale(1); }
    30% { opacity: 1; transform: scale(1.2); }
  }

  /* Form */
  .labyrinth-form {
    padding: 16px 0 24px;
    border-top: 1px solid var(--color-border);
    background: var(--color-background);
  }

  .form-input-wrapper {
    display: flex;
    gap: 12px;
    align-items: center;
  }

  .labyrinth-input {
    flex: 1;
    padding: 14px 20px;
    border: 1px solid var(--color-border);
    border-radius: 24px;
    font-size: 16px;
    font-family: var(--font-body);
    background: var(--color-background);
    color: var(--color-text);
    outline: none;
    transition: border-color 0.2s ease, box-shadow 0.2s ease;
  }

  .labyrinth-input:focus {
    border-color: var(--color-primary);
    box-shadow: 0 0 0 3px rgba(150, 106, 133, 0.1);
  }

  .labyrinth-input::placeholder {
    color: var(--color-text-muted);
  }

  .labyrinth-submit {
    width: 48px;
    height: 48px;
    border-radius: 50%;
    border: none;
    background: var(--color-primary);
    color: white;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: transform 0.2s ease, background 0.2s ease;
  }

  .labyrinth-submit:hover {
    transform: scale(1.05);
  }

  .labyrinth-submit:active {
    transform: scale(0.95);
  }

  .labyrinth-submit:disabled {
    opacity: 0.5;
    cursor: not-allowed;
    transform: none;
  }

  /* Richer Tyrian purple for dark mode send button */
  :global([data-theme="dark"]) .labyrinth-submit {
    background: #6d4463;
  }

  .form-hints {
    display: flex;
    align-items: center;
    justify-content: center;
    gap: 8px;
    margin-top: 12px;
    font-size: 12px;
    color: var(--color-text-muted);
  }

  .form-hints kbd {
    font-family: 'SF Mono', Monaco, monospace;
    font-size: 10px;
    padding: 2px 6px;
    background: var(--color-background-alt);
    border-radius: 4px;
  }

  .hint-separator {
    opacity: 0.3;
  }

  .hint-paste {
    opacity: 0.7;
  }

  /* Hidden file input */
  .image-input-hidden {
    position: absolute;
    width: 1px;
    height: 1px;
    padding: 0;
    margin: -1px;
    overflow: hidden;
    clip: rect(0, 0, 0, 0);
    border: 0;
  }

  /* Attachment Preview Bar */
  .attachment-preview-bar {
    display: flex;
    align-items: center;
    gap: 8px;
    padding: 8px 12px;
    margin-bottom: 8px;
    background: var(--color-background-alt);
    border-radius: 12px;
    border: 1px solid var(--color-border);
  }

  .attachment-thumbnail {
    width: 48px;
    height: 48px;
    object-fit: cover;
    border-radius: 8px;
    border: 1px solid var(--color-border);
  }

  .attachment-dismiss {
    width: 24px;
    height: 24px;
    border-radius: 50%;
    border: none;
    background: var(--color-text-muted);
    color: var(--color-background);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    margin-left: auto;
    transition: background 0.2s ease, transform 0.2s ease;
  }

  .attachment-dismiss:hover {
    background: var(--color-text);
    transform: scale(1.1);
  }

  /* Attach Button */
  .attach-button {
    width: 44px;
    height: 44px;
    border-radius: 50%;
    border: 1px solid var(--color-border);
    background: var(--color-background);
    color: var(--color-text-muted);
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    transition: all 0.2s ease;
    flex-shrink: 0;
  }

  .attach-button:hover {
    border-color: var(--color-primary);
    color: var(--color-primary);
    background: rgba(150, 106, 133, 0.05);
  }

  .attach-button:disabled {
    opacity: 0.5;
    cursor: not-allowed;
  }

  :global([data-theme='dark']) .attach-button:hover {
    background: rgba(201, 160, 184, 0.1);
  }

  /* Message Image (inline in messages) */
  :global(.message-image) {
    max-width: 200px;
    max-height: 200px;
    object-fit: contain;
    border-radius: 8px;
    margin-bottom: 8px;
    cursor: pointer;
    transition: transform 0.2s ease;
  }

  :global(.message-image:hover) {
    transform: scale(1.02);
  }

  /* Image lightbox overlay */
  :global(.image-lightbox) {
    position: fixed;
    inset: 0;
    z-index: 1000;
    background: rgba(0, 0, 0, 0.9);
    display: flex;
    align-items: center;
    justify-content: center;
    cursor: zoom-out;
    animation: lightbox-fade-in 0.2s ease;
  }

  @keyframes lightbox-fade-in {
    from { opacity: 0; }
    to { opacity: 1; }
  }

  :global(.image-lightbox img) {
    max-width: 90vw;
    max-height: 90vh;
    object-fit: contain;
    border-radius: 8px;
    box-shadow: 0 20px 60px rgba(0, 0, 0, 0.5);
  }

  /* Mobile */
  @media (max-width: 768px) {
    .labyrinth-header {
      padding: 12px 16px;
    }

    .labyrinth-title h1 {
      font-size: 16px;
    }

    .labyrinth-title p {
      display: none;
    }

    .labyrinth-menu-container {
      right: 16px;
    }

    .labyrinth-menu {
      right: 0;
    }

    .labyrinth-container {
      padding: 0 20px;
    }

    :global(.message) {
      max-width: 90%;
    }

    .form-hints {
      display: none;
    }
  }

  /* Dark mode adjustments */
  :global([data-theme='dark']) .labyrinth-input {
    background: rgba(255, 255, 255, 0.05);
  }

  :global([data-theme='dark']) .labyrinth-input:focus {
    box-shadow: 0 0 0 3px rgba(201, 160, 184, 0.2);
  }

  /* Toast notification */
  :global(.labyrinth-toast) {
    position: fixed;
    bottom: 100px;
    left: 50%;
    transform: translateX(-50%) translateY(20px);
    background: var(--color-text);
    color: var(--color-background);
    padding: 12px 24px;
    border-radius: 8px;
    font-size: 14px;
    font-weight: 500;
    opacity: 0;
    transition: all 0.2s ease;
    z-index: 1000;
    pointer-events: none;
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
  }

  :global(.labyrinth-toast.is-visible) {
    opacity: 1;
    transform: translateX(-50%) translateY(0);
  }

  :global([data-theme='dark']) :global(.labyrinth-toast) {
    box-shadow: 0 4px 20px rgba(0, 0, 0, 0.4);
  }
</style>

<script>
  import { getSoulOrchestrator, type OrchestratorConfig } from '../lib/soul/opensouls/perception/SoulOrchestrator';
  import type { SoulOrchestrator } from '../lib/soul/opensouls/perception/SoulOrchestrator';
  import { StreamRenderer, injectStreamingStyles } from '../lib/soul/streamRenderer';
  import { getTriggerManager } from '../lib/soul/triggers';

  interface ImageAttachment {
    dataUrl: string;
    mimeType: string;
    sizeBytes: number;
  }

  interface ChatMessage {
    id: string;
    role: 'user' | 'assistant';
    content: string;
    timestamp: number;
    page?: string;
    image?: ImageAttachment;
  }

  // Max image size: 5MB
  const MAX_IMAGE_SIZE = 5 * 1024 * 1024;

  interface ConversationThread {
    messages: ChatMessage[];
    lastUpdated: number;
    schemaVersion: number;
  }

  // ─────────────────────────────────────────────────────────────
  // Name Extraction (Instant, no LLM call)
  // Pattern from Open Souls samantha-dreams
  // NOTE: Duplicated from src/lib/soul/opensouls/core/utils.ts
  //       because this inline script runs in browser, not Node.
  // ─────────────────────────────────────────────────────────────

  const NAME_PATTERNS = [
    // Standard introductions
    /^(?:hi[,!]?\s+)?(?:I'm|I am|my name is|this is|it's)\s+([a-z]+)/i,
    /^(?:hi|hey|hello)[,!]?\s+(?:I'm|it's|this is)\s+([a-z]+)/i,
    // Name at start or end
    /^([a-z]+)\s+here[.!]?$/i,
    /^-\s*([a-z]+)$/i,
    // Casual variations
    /(?:call me|I go by|name's|just)\s+([a-z]+)/i,
    // Just a name (short messages like "Tomar" or "I'm Tomar!")
    /^(?:I'm|im)\s+([a-z]+)[.!]?$/i,
    // Name anywhere in "my name is X" pattern
    /my name (?:is|'s)\s+([a-z]+)/i,
  ];

  function extractNameHeuristic(content: string): string | null {
    console.log('[Name Extraction] Checking message:', content);
    for (const pattern of NAME_PATTERNS) {
      const match = content.match(pattern);
      if (match?.[1]) {
        // Normalize: uppercase first letter, lowercase rest
        const rawName = match[1].trim();
        const name = rawName.charAt(0).toUpperCase() + rawName.slice(1).toLowerCase();
        // Validate: 2-20 chars, only letters
        if (name.length >= 2 && name.length <= 20 && /^[A-Za-z]+$/.test(name)) {
          console.log('[Name Extraction] Found name:', name);
          return name;
        }
      }
    }
    console.log('[Name Extraction] No name found');
    return null;
  }

  function saveUserName(name: string): void {
    try {
      const memory = JSON.parse(localStorage.getItem('minoan-soul-memory') || '{}');
      memory.userName = name;
      localStorage.setItem('minoan-soul-memory', JSON.stringify(memory));
      console.log('[Labyrinth] Extracted user name:', name);
    } catch (e) {
      console.warn('[Labyrinth] Failed to save userName:', e);
    }
  }

  function getUserName(): string | undefined {
    try {
      const memory = JSON.parse(localStorage.getItem('minoan-soul-memory') || '{}');
      return memory.userName;
    } catch {
      return undefined;
    }
  }

  class LabyrinthChat {
    private history: HTMLElement;
    private form: HTMLFormElement;
    private input: HTMLInputElement;
    private submitBtn: HTMLButtonElement;
    private emptyState: HTMLElement;
    private isLoading = false;

    // Orchestrator integration (Open Souls paradigm)
    private orchestrator: SoulOrchestrator | null = null;
    private currentRenderer: StreamRenderer | null = null;
    private pendingResolve: ((response: string) => void) | null = null;

    // Soul state indicator
    private stateIndicator: HTMLElement;
    private stateDot: HTMLElement;
    private stateText: HTMLElement;

    // Divine feminine background
    private goddessBackground: HTMLElement;

    // Vision background (AI-generated)
    private visionBackground: HTMLElement;

    // Tarot background (generated Minoan tarot cards)
    private tarotBackground: HTMLElement;

    // Archive indicator
    private archiveIndicator: HTMLElement;

    // Image attachment elements
    private imageInput: HTMLInputElement;
    private attachButton: HTMLButtonElement;
    private attachmentPreview: HTMLElement;
    private attachmentThumbnail: HTMLImageElement;
    private attachmentDismiss: HTMLButtonElement;

    // Pending image attachment
    private pendingImage: ImageAttachment | null = null;

    // Goddess background timeout (for auto-hide)
    private goddessTimeout: ReturnType<typeof setTimeout> | null = null;

    // Vision background timeout (for auto-hide)
    private visionTimeout: ReturnType<typeof setTimeout> | null = null;

    // Tarot background timeout (for auto-hide)
    private tarotTimeout: ReturnType<typeof setTimeout> | null = null;

    // State display mapping
    private readonly stateLabels: Record<string, string> = {
      greeting: 'Kothar is pondering...',
      curious: 'Kothar is curious...',
      engaged: 'Kothar is contemplating...',
      ready: 'Kothar is attending...',
      returning: 'Kothar is remembering...',
      dormant: 'Kothar is dreaming...',
      exiting: 'Kothar is reflecting...',
    };

    constructor() {
      this.history = document.getElementById('conversation-history')!;
      this.form = document.getElementById('labyrinth-form') as HTMLFormElement;
      this.input = document.getElementById('labyrinth-input') as HTMLInputElement;
      this.submitBtn = this.form.querySelector('.labyrinth-submit') as HTMLButtonElement;
      this.emptyState = document.getElementById('conversation-empty')!;

      // Soul state indicator elements
      this.stateIndicator = document.getElementById('soul-state-indicator')!;
      this.stateDot = document.getElementById('soul-state-dot')!;
      this.stateText = document.getElementById('soul-state-text')!;

      // Divine feminine background, vision background, tarot background, and archive indicator
      this.goddessBackground = document.getElementById('goddess-background')!;
      this.visionBackground = document.getElementById('vision-background')!;
      this.tarotBackground = document.getElementById('tarot-background')!;
      this.archiveIndicator = document.getElementById('archive-indicator')!;

      // Image attachment elements
      this.imageInput = document.getElementById('image-input') as HTMLInputElement;
      this.attachButton = document.getElementById('attach-button') as HTMLButtonElement;
      this.attachmentPreview = document.getElementById('attachment-preview')!;
      this.attachmentThumbnail = document.getElementById('attachment-thumbnail') as HTMLImageElement;
      this.attachmentDismiss = document.getElementById('attachment-dismiss') as HTMLButtonElement;

      this.init();
    }

    private init() {
      // Inject streaming styles
      injectStreamingStyles();

      // Initialize orchestrator (async, non-blocking)
      this.initOrchestrator();

      // Initialize soul state indicator
      this.updateSoulState();

      // Personalize input placeholder with userName
      const userName = getUserName();
      this.input.placeholder = userName
        ? `Ask Kothar, ${userName}...`
        : 'Ask Kothar...';

      // Load conversation history
      this.renderHistory();

      // Form submission
      this.form.addEventListener('submit', (e) => {
        e.preventDefault();
        this.sendMessage();
      });

      // Image paste handler
      this.input.addEventListener('paste', (e) => {
        this.handlePaste(e);
      });

      // File input change handler
      this.imageInput.addEventListener('change', () => {
        this.handleFileSelect();
      });

      // Attach button click handler
      this.attachButton.addEventListener('click', () => {
        this.imageInput.click();
      });

      // Attachment dismiss handler
      this.attachmentDismiss.addEventListener('click', () => {
        this.clearPendingImage();
      });

      // Voice input (from VoiceButton in chat mode)
      document.addEventListener('voice:transcript', ((e: CustomEvent<{ transcript: string }>) => {
        const { transcript } = e.detail;
        if (transcript) {
          this.input.value = transcript;
          this.sendMessage();
        }
      }) as EventListener);

      // Divine feminine background event listener
      document.addEventListener('soul:background', ((e: CustomEvent) => {
        this.handleGoddessBackground(e.detail);
      }) as EventListener);

      // Archive indicator event listener (from SSE stream)
      document.addEventListener('soul:archive', ((e: CustomEvent) => {
        this.setArchiveIndicator(e.detail.active);
      }) as EventListener);

      // Vision background event listener (from SSE stream or dispatch)
      document.addEventListener('soul:vision', ((e: CustomEvent) => {
        this.handleVisionBackground(e.detail);
      }) as EventListener);

      // Tarot background event listener (from SSE stream)
      document.addEventListener('soul:tarot', ((e: CustomEvent) => {
        this.handleTarotBackground(e.detail);
      }) as EventListener);

      // Image analysis status event listener
      document.addEventListener('soul:imageAnalysis', ((e: CustomEvent) => {
        this.handleImageAnalysisStatus(e.detail);
      }) as EventListener);

      // Check for message ID in URL (deep link)
      const params = new URLSearchParams(window.location.search);
      const msgId = params.get('msg');
      if (msgId) {
        setTimeout(() => this.scrollToMessage(msgId), 100);
      }

      // Focus input
      this.input.focus();
    }

    private async initOrchestrator() {
      try {
        // Fetch soul personality from API
        const response = await fetch('/api/soul/personality');
        const { personality } = await response.json();

        // Configure orchestrator with API mode and streaming callbacks
        const config: OrchestratorConfig = {
          debug: true,
          apiMode: true,  // Delegate LLM calls to server-side endpoints
          onStreamStart: () => {
            console.log('[Labyrinth] Stream started');
            // StreamRenderer.start() is already called in sendMessage
          },
          onStreamChunk: (chunk: string) => {
            // Append chunk to current renderer
            if (this.currentRenderer) {
              this.currentRenderer.appendChunk(chunk);
              this.scrollToBottom();
            }
          },
          onStreamEnd: () => {
            console.log('[Labyrinth] Stream ended');
          },
          onResponse: (response: string) => {
            // Finalize streaming and resolve promise
            if (this.currentRenderer) {
              this.currentRenderer.finalize(response, this.formatContent.bind(this));
            }
            if (this.pendingResolve) {
              this.pendingResolve(response);
              this.pendingResolve = null;
            }
          },
          onToast: (message: string, duration: number) => {
            // Dispatch to FloatingDialogue
            document.dispatchEvent(new CustomEvent('soul:toast', {
              detail: { message, duration, type: 'info' }
            }));
          },
          onWhispersUpdate: (whispers: string) => {
            // Show whispers as hint toast (optional, for debugging)
            console.log('[Labyrinth] Visitor whispers updated:', whispers.slice(0, 100) + '...');
            // Could dispatch a hint toast:
            // document.dispatchEvent(new CustomEvent('soul:toast', {
            //   detail: { message: whispers, duration: 5000, type: 'hint' }
            // }));
          },
        };

        // Get singleton orchestrator and initialize
        this.orchestrator = getSoulOrchestrator(config);
        await this.orchestrator.init(personality);

        console.log('[Labyrinth] SoulOrchestrator initialized');
      } catch (error) {
        console.error('[Labyrinth] Failed to initialize orchestrator:', error);
        // Orchestrator will be null, sendMessage will show error
      }
    }

    private loadConversation(): ConversationThread {
      try {
        const stored = localStorage.getItem('minoan-soul-conversation');
        if (stored) {
          return JSON.parse(stored);
        }
      } catch (e) {
        console.error('Failed to load conversation:', e);
      }
      return { messages: [], lastUpdated: Date.now(), schemaVersion: 1 };
    }

    private saveConversation(thread: ConversationThread) {
      localStorage.setItem('minoan-soul-conversation', JSON.stringify(thread));
    }

    private renderHistory() {
      const thread = this.loadConversation();

      if (thread.messages.length === 0) {
        this.emptyState.style.display = 'flex';
        return;
      }

      this.emptyState.style.display = 'none';

      // Clear existing messages (except empty state)
      this.history.querySelectorAll('.message').forEach(el => el.remove());

      // Render messages
      thread.messages.forEach(msg => {
        this.renderMessage(msg);
      });

      // Scroll to bottom
      this.scrollToBottom();
    }

    private renderMessage(msg: ChatMessage, isLoading = false) {
      const messageEl = document.createElement('div');
      messageEl.className = `message message-${msg.role}${isLoading ? ' message-loading' : ''}`;
      messageEl.id = `msg-${msg.id}`;

      const avatarIcon = msg.role === 'user'
        ? '<svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M20 21v-2a4 4 0 0 0-4-4H8a4 4 0 0 0-4 4v2"></path><circle cx="12" cy="7" r="4"></circle></svg>'
        : '<img src="/images/avatars/minoan-avatar.webp" alt="Minoan" class="minoan-avatar-img" />';

      const content = isLoading
        ? '<span class="loading-dot"></span><span class="loading-dot"></span><span class="loading-dot"></span>'
        : this.formatContent(msg.content);

      const time = new Date(msg.timestamp).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' });

      // Build structure using DOM APIs to prevent XSS
      const avatarDiv = document.createElement('div');
      avatarDiv.className = 'message-avatar';
      avatarDiv.innerHTML = avatarIcon; // Safe: avatarIcon is hardcoded, not user input

      const bubbleDiv = document.createElement('div');
      bubbleDiv.className = 'message-bubble';

      // Add image using DOM API if present (prevents XSS from dataUrl)
      if (msg.image && this.isValidImageDataUrl(msg.image.dataUrl)) {
        const imageEl = document.createElement('img');
        imageEl.src = msg.image.dataUrl;
        imageEl.alt = 'Attached image';
        imageEl.className = 'message-image';
        imageEl.dataset.lightbox = '';
        imageEl.addEventListener('click', () => {
          this.openLightbox(imageEl.src);
        });
        bubbleDiv.appendChild(imageEl);
      }

      const contentDiv = document.createElement('div');
      contentDiv.className = 'message-content';
      contentDiv.innerHTML = content; // Safe: content is sanitized by formatContent

      const metaDiv = document.createElement('div');
      metaDiv.className = 'message-meta';
      metaDiv.textContent = time;

      bubbleDiv.appendChild(contentDiv);
      bubbleDiv.appendChild(metaDiv);
      messageEl.appendChild(avatarDiv);
      messageEl.appendChild(bubbleDiv);

      this.history.appendChild(messageEl);
      return messageEl;
    }

    /**
     * Update soul state indicator from localStorage
     */
    private updateSoulState() {
      try {
        const memory = JSON.parse(localStorage.getItem('minoan-soul-memory') || '{}');
        const state = memory.currentState || 'greeting';
        const isReturning = (memory.visitCount || 1) > 1;

        // Use 'returning' state if this is a returning visitor and in greeting
        const displayState = (isReturning && state === 'greeting') ? 'returning' : state;

        // Update the dot's data attribute for CSS styling
        this.stateDot.setAttribute('data-state', displayState);

        // Update the text
        const label = this.stateLabels[displayState] || this.stateLabels.greeting;
        this.stateText.textContent = label;

        console.log('[Labyrinth] Soul state updated:', displayState);
      } catch (e) {
        // Default to greeting state
        this.stateDot.setAttribute('data-state', 'greeting');
        this.stateText.textContent = this.stateLabels.greeting;
      }
    }

    /**
     * Handle divine feminine background manifestation
     */
    private handleGoddessBackground(payload: { image: string; opacity?: number; duration?: number }) {
      if (!this.goddessBackground) return;

      if (payload.image === 'goddess') {
        // Clear any existing timeout
        if (this.goddessTimeout) {
          clearTimeout(this.goddessTimeout);
          this.goddessTimeout = null;
        }

        // Manifest the goddess
        this.goddessBackground.classList.add('active');

        // Set custom opacity if provided
        if (payload.opacity) {
          const beforeEl = this.goddessBackground.querySelector('::before') as HTMLElement;
          if (beforeEl) {
            beforeEl.style.opacity = String(payload.opacity);
          }
        }

        console.log('[Labyrinth] Divine feminine manifested');

        // Auto-hide after duration (default 30s)
        const duration = payload.duration || 30000;
        if (duration > 0) {
          this.goddessTimeout = setTimeout(() => {
            this.goddessBackground.classList.remove('active');
            console.log('[Labyrinth] Divine feminine faded');
          }, duration);
        }
      } else {
        // Hide the goddess
        this.goddessBackground.classList.remove('active');
        if (this.goddessTimeout) {
          clearTimeout(this.goddessTimeout);
          this.goddessTimeout = null;
        }
      }
    }

    /**
     * Handle AI-generated vision background manifestation
     */
    private handleVisionBackground(payload: { dataUrl: string; prompt?: string; displayMode?: string; duration?: number }) {
      if (!this.visionBackground) return;

      // Clear any existing timeout
      if (this.visionTimeout) {
        clearTimeout(this.visionTimeout);
        this.visionTimeout = null;
      }

      if (payload.dataUrl && payload.displayMode !== 'none') {
        // Set the background image
        const bgElement = this.visionBackground.querySelector('::before') as HTMLElement;
        // Since we can't directly style ::before, we use CSS custom properties
        this.visionBackground.style.setProperty('--vision-image', `url(${payload.dataUrl})`);

        // Apply the background image via inline style on the element itself
        // (We'll add a secondary element for the actual image)
        let imageLayer = this.visionBackground.querySelector('.vision-image-layer') as HTMLElement;
        if (!imageLayer) {
          imageLayer = document.createElement('div');
          imageLayer.className = 'vision-image-layer';
          imageLayer.style.cssText = `
            position: absolute;
            inset: 0;
            background-size: cover;
            background-position: center;
            background-repeat: no-repeat;
            opacity: 0.15;
            filter: sepia(0.2) saturate(0.9);
            animation: vision-breathe 15s ease-in-out infinite;
          `;
          this.visionBackground.insertBefore(imageLayer, this.visionBackground.firstChild);
        }
        imageLayer.style.backgroundImage = `url(${payload.dataUrl})`;

        // Manifest the vision
        this.visionBackground.classList.add('active');

        console.log('[Labyrinth] Vision manifested:', payload.prompt?.slice(0, 50) + '...');

        // Auto-hide after duration (default 30s)
        const duration = payload.duration || 30000;
        if (duration > 0) {
          this.visionTimeout = setTimeout(() => {
            this.visionBackground.classList.remove('active');
            console.log('[Labyrinth] Vision faded');
          }, duration);
        }
      } else {
        // Hide the vision
        this.visionBackground.classList.remove('active');
      }
    }

    /**
     * Handle Minoan tarot card background manifestation
     * World-class implementation with cinematic entrance, polyrhythmic halos,
     * floating particles, and graceful exit
     */
    private handleTarotBackground(payload: {
      dataUrl: string;
      prompt?: string;
      cardName?: string;
      cardNumber?: string;
      displayMode?: string;
      duration?: number
    }) {
      // [Tarot Debug] Event received logging
      console.log('[Labyrinth] soul:tarot event received:', {
        hasDataUrl: !!payload.dataUrl,
        dataUrlLength: payload.dataUrl?.length ?? 0,
        cardName: payload.cardName,
        cardNumber: payload.cardNumber,
        duration: payload.duration,
        displayMode: payload.displayMode,
      });

      if (!this.tarotBackground) return;

      // Clear any existing timeout
      if (this.tarotTimeout) {
        clearTimeout(this.tarotTimeout);
        this.tarotTimeout = null;
      }

      // Remove exiting class if re-triggering
      this.tarotBackground.classList.remove('exiting', 'settled');

      if (payload.dataUrl && payload.displayMode !== 'none') {
        const isMobile = window.innerWidth <= 768;

        // ═══════════════════════════════════════════════════════════════════
        // IMAGE LAYER - Central tarot card with cinematic entrance
        // ═══════════════════════════════════════════════════════════════════
        let imageLayer = this.tarotBackground.querySelector('.tarot-image-layer') as HTMLElement;
        if (!imageLayer) {
          imageLayer = document.createElement('div');
          imageLayer.className = 'tarot-image-layer';
          this.tarotBackground.insertBefore(imageLayer, this.tarotBackground.firstChild);
        }

        // Responsive card size: larger on mobile
        const cardSize = isMobile ? '35%' : '22%';
        // Golden ratio positioning: 61.8% from top on desktop, centered on mobile
        const goldenRatioTop = isMobile ? '50%' : '61.8%';

        imageLayer.style.cssText = `
          position: absolute;
          top: ${goldenRatioTop};
          left: 50%;
          transform: translate(-50%, -50%);
          width: ${cardSize};
          aspect-ratio: 3 / 4;
          background-size: cover;
          background-position: center;
          background-repeat: no-repeat;
          opacity: 0;
          filter: blur(40px);
          transform-origin: center center;
          animation: tarot-entrance-glow 1s ease-out forwards,
                     tarot-entrance-materialize 1.5s ease-out 0.8s forwards,
                     tarot-breathe 18s ease-in-out 2.3s infinite;
          z-index: 2;
        `;
        imageLayer.style.backgroundImage = `url(${payload.dataUrl})`;

        // ═══════════════════════════════════════════════════════════════════
        // DEPTH-OF-FIELD LAYER - Soft blur on edges for depth
        // ═══════════════════════════════════════════════════════════════════
        let dofLayer = this.tarotBackground.querySelector('.tarot-dof-layer') as HTMLElement;
        if (!dofLayer) {
          dofLayer = document.createElement('div');
          dofLayer.className = 'tarot-dof-layer';
          imageLayer.after(dofLayer);
        }

        dofLayer.style.cssText = `
          position: absolute;
          top: ${goldenRatioTop};
          left: 50%;
          transform: translate(-50%, -50%);
          width: ${cardSize};
          aspect-ratio: 3 / 4;
          background-size: cover;
          background-position: center;
          background-repeat: no-repeat;
          filter: blur(6px);
          opacity: 0;
          mask-image: radial-gradient(
            ellipse 80% 85% at 50% 50%,
            transparent 50%,
            black 90%
          );
          -webkit-mask-image: radial-gradient(
            ellipse 80% 85% at 50% 50%,
            transparent 50%,
            black 90%
          );
          z-index: 1;
          animation: tarot-entrance-materialize 1.5s ease-out 0.8s forwards;
          pointer-events: none;
        `;
        dofLayer.style.backgroundImage = `url(${payload.dataUrl})`;

        // ═══════════════════════════════════════════════════════════════════
        // INNER HALO - 18s cycle (matches card breathing)
        // ═══════════════════════════════════════════════════════════════════
        let innerHalo = this.tarotBackground.querySelector('.tarot-halo-inner') as HTMLElement;
        if (!innerHalo) {
          innerHalo = document.createElement('div');
          innerHalo.className = 'tarot-halo-inner';
          dofLayer.after(innerHalo);
        }

        const haloSizeInner = isMobile ? '38%' : '24%';
        innerHalo.style.cssText = `
          position: absolute;
          top: ${goldenRatioTop};
          left: 50%;
          width: ${haloSizeInner};
          aspect-ratio: 3 / 4;
          transform: translate(-50%, -50%) scale(0.95);
          pointer-events: none;
          background: transparent;
          border-radius: 12px;
          opacity: 0;
          z-index: 3;
          animation: tarot-halo-entrance 1s ease-out 1.2s forwards,
                     tarot-halo-inner 18s ease-in-out 2.2s infinite;
        `;

        // ═══════════════════════════════════════════════════════════════════
        // OUTER HALO - 23s cycle (prime number avoids sync for organic feel)
        // ═══════════════════════════════════════════════════════════════════
        let outerHalo = this.tarotBackground.querySelector('.tarot-halo-outer') as HTMLElement;
        if (!outerHalo) {
          outerHalo = document.createElement('div');
          outerHalo.className = 'tarot-halo-outer';
          innerHalo.after(outerHalo);
        }

        const haloSizeOuter = isMobile ? '45%' : '30%';
        outerHalo.style.cssText = `
          position: absolute;
          top: ${goldenRatioTop};
          left: 50%;
          width: ${haloSizeOuter};
          aspect-ratio: 3 / 4;
          transform: translate(-50%, -50%) scale(0.95);
          pointer-events: none;
          background: transparent;
          border-radius: 16px;
          opacity: 0;
          z-index: 0;
          animation: tarot-halo-entrance 1.2s ease-out 0.5s forwards,
                     tarot-halo-outer 23s ease-in-out 1.7s infinite;
        `;

        // ═══════════════════════════════════════════════════════════════════
        // NOISE LAYER - Atmospheric grain texture
        // ═══════════════════════════════════════════════════════════════════
        let noiseLayer = this.tarotBackground.querySelector('.tarot-noise') as HTMLElement;
        if (!noiseLayer) {
          noiseLayer = document.createElement('div');
          noiseLayer.className = 'tarot-noise';
          outerHalo.after(noiseLayer);
        }

        noiseLayer.style.cssText = `
          position: absolute;
          inset: -10%;
          width: 120%;
          height: 120%;
          pointer-events: none;
          opacity: 0.03;
          background-image: url("data:image/svg+xml,%3Csvg viewBox='0 0 200 200' xmlns='http://www.w3.org/2000/svg'%3E%3Cfilter id='noise'%3E%3CfeTurbulence type='fractalNoise' baseFrequency='0.85' numOctaves='4' stitchTiles='stitch'/%3E%3C/filter%3E%3Crect width='100%25' height='100%25' filter='url(%23noise)'/%3E%3C/svg%3E");
          animation: tarot-noise 0.5s steps(10) infinite;
          z-index: 6;
          mix-blend-mode: overlay;
        `;

        // ═══════════════════════════════════════════════════════════════════
        // CHROMATIC ABERRATION LAYER - Subtle RGB shift for mystical depth
        // ═══════════════════════════════════════════════════════════════════
        let chromaticLayer = this.tarotBackground.querySelector('.tarot-chromatic') as HTMLElement;
        if (!chromaticLayer) {
          chromaticLayer = document.createElement('div');
          chromaticLayer.className = 'tarot-chromatic';
          noiseLayer.after(chromaticLayer);
        }

        chromaticLayer.style.cssText = `
          position: absolute;
          top: ${goldenRatioTop};
          left: 50%;
          transform: translate(calc(-50% + 2px), -50%);
          width: ${cardSize};
          aspect-ratio: 3 / 4;
          background-size: cover;
          background-position: center;
          background-repeat: no-repeat;
          opacity: 0;
          mix-blend-mode: screen;
          filter: blur(1px);
          z-index: 1;
          pointer-events: none;
          animation: tarot-entrance-materialize 1.5s ease-out 0.8s forwards;
        `;
        chromaticLayer.style.backgroundImage = `url(${payload.dataUrl})`;
        // Set final opacity via animation end state
        chromaticLayer.style.setProperty('--chromatic-opacity', '0.04');

        // ═══════════════════════════════════════════════════════════════════
        // PARTICLES - Floating gold dust motes
        // ═══════════════════════════════════════════════════════════════════
        let particleContainer = this.tarotBackground.querySelector('.tarot-particles') as HTMLElement;
        if (!particleContainer) {
          particleContainer = document.createElement('div');
          particleContainer.className = 'tarot-particles';
          this.tarotBackground.appendChild(particleContainer);

          // Adaptive particle count based on device capability
          const isLowEndDevice = (navigator.hardwareConcurrency ?? 4) <= 4 ||
                                 ((navigator as any).deviceMemory ?? 4) <= 4;
          const particleCount = isLowEndDevice ? 8 : (isMobile ? 10 : 15);
          this.createTarotParticles(particleContainer, particleCount);

          console.log(`[Labyrinth] Created ${particleCount} particles (lowEnd: ${isLowEndDevice}, mobile: ${isMobile})`);
        }

        // [Tarot Debug] DOM manipulation logging
        console.log('[Labyrinth] Tarot layers created with cinematic entrance');

        // ═══════════════════════════════════════════════════════════════════
        // CARD NAME - Incised Roman capitals with delayed reveal
        // ═══════════════════════════════════════════════════════════════════
        let nameOverlay = this.tarotBackground.querySelector('.tarot-card-name') as HTMLElement;
        if (payload.cardName && payload.cardNumber) {
          if (!nameOverlay) {
            nameOverlay = document.createElement('div');
            nameOverlay.className = 'tarot-card-name';
            this.tarotBackground.appendChild(nameOverlay);
          }
          nameOverlay.textContent = `${payload.cardNumber} · ${payload.cardName}`;
          // Reset animation by re-triggering
          nameOverlay.style.animation = 'none';
          nameOverlay.offsetHeight; // Force reflow
          nameOverlay.style.animation = '';
        } else if (nameOverlay) {
          nameOverlay.remove();
        }

        // ═══════════════════════════════════════════════════════════════════
        // MOBILE TOUCH RESPONSE
        // ═══════════════════════════════════════════════════════════════════
        if ('ontouchstart' in window) {
          this.setupTarotTouchResponse();
        }

        // Manifest the tarot
        this.tarotBackground.classList.add('active');

        console.log(`[Labyrinth] Tarot manifested: ${payload.cardNumber} - ${payload.cardName}`);

        // Remove will-change after entrance settles (3s) for performance
        setTimeout(() => {
          this.tarotBackground.classList.add('settled');
        }, 3000);

        // Auto-hide after duration with graceful exit animation
        const duration = payload.duration || 30000;
        if (duration > 0) {
          this.tarotTimeout = setTimeout(() => {
            // Start exit animation 2s before removal
            this.tarotBackground.classList.add('exiting');
            console.log('[Labyrinth] Tarot exiting...');

            setTimeout(() => {
              this.tarotBackground.classList.remove('active', 'exiting', 'settled');
              console.log('[Labyrinth] Tarot faded');
            }, 2000);
          }, duration - 2000); // Start exit 2s before intended end
        }
      } else {
        // Hide the tarot immediately
        this.tarotBackground.classList.remove('active', 'exiting', 'settled');
      }
    }

    /**
     * Create floating gold dust particles for tarot background
     */
    private createTarotParticles(container: HTMLElement, count: number) {
      // Clear existing particles
      container.innerHTML = '';

      for (let i = 0; i < count; i++) {
        const particle = document.createElement('div');
        particle.className = 'tarot-particle';

        // Randomize particle properties
        const size = 1 + Math.random() * 2; // 1-3px
        const duration = 6 + Math.random() * 8; // 6-14s
        const delay = Math.random() * 5; // 0-5s delay
        const driftX = (Math.random() - 0.5) * 60; // -30 to 30px
        const driftY = -20 - Math.random() * 40; // -20 to -60px (upward)
        const opacity = 0.2 + Math.random() * 0.3; // 0.2-0.5

        // Random position within center area
        const left = 30 + Math.random() * 40; // 30-70% from left
        const top = 30 + Math.random() * 40; // 30-70% from top

        particle.style.cssText = `
          left: ${left}%;
          top: ${top}%;
          width: ${size}px;
          height: ${size}px;
          --duration: ${duration}s;
          --delay: ${delay}s;
          --drift-x: ${driftX}px;
          --drift-y: ${driftY}px;
          --particle-opacity: ${opacity};
        `;

        container.appendChild(particle);
      }
    }

    /**
     * Setup touch response for mobile tarot interaction
     */
    private setupTarotTouchResponse() {
      // Remove existing listeners to prevent duplicates
      this.tarotBackground.removeEventListener('touchstart', this.handleTarotTouch);
      this.tarotBackground.removeEventListener('touchend', this.handleTarotTouchEnd);

      this.handleTarotTouch = (e: TouchEvent) => {
        const touch = e.touches[0];
        const rect = this.tarotBackground.getBoundingClientRect();
        const x = ((touch.clientX - rect.left) / rect.width - 0.5) * 2;
        const y = ((touch.clientY - rect.top) / rect.height - 0.5) * 2;

        this.tarotBackground.style.setProperty('--touch-x', `${50 + x * 5}%`);
        this.tarotBackground.style.setProperty('--touch-y', `${50 + y * 5}%`);
        this.tarotBackground.classList.add('touched');
      };

      this.handleTarotTouchEnd = () => {
        this.tarotBackground.classList.remove('touched');
      };

      this.tarotBackground.addEventListener('touchstart', this.handleTarotTouch, { passive: true });
      this.tarotBackground.addEventListener('touchend', this.handleTarotTouchEnd, { passive: true });
    }

    // Touch handlers (stored as instance methods for removal)
    private handleTarotTouch: (e: TouchEvent) => void = () => {};
    private handleTarotTouchEnd: () => void = () => {};

    /**
     * Cleanup method for navigation/unmount
     * Removes event listeners to prevent memory leaks
     */
    public destroy() {
      // Cleanup tarot touch listeners
      if (this.tarotBackground) {
        this.tarotBackground.removeEventListener('touchstart', this.handleTarotTouch);
        this.tarotBackground.removeEventListener('touchend', this.handleTarotTouchEnd);
      }

      // Clear any pending timeouts
      if (this.goddessTimeout) {
        clearTimeout(this.goddessTimeout);
        this.goddessTimeout = null;
      }
      if (this.visionTimeout) {
        clearTimeout(this.visionTimeout);
        this.visionTimeout = null;
      }
      if (this.tarotTimeout) {
        clearTimeout(this.tarotTimeout);
        this.tarotTimeout = null;
      }

      console.log('[Labyrinth] LabyrinthChat destroyed, listeners cleaned up');
    }

    /**
     * Show/hide archive indicator during RAG retrieval
     */
    private setArchiveIndicator(active: boolean) {
      if (!this.archiveIndicator) return;

      if (active) {
        this.archiveIndicator.classList.add('active');
        console.log('[Labyrinth] Archive search started');
      } else {
        this.archiveIndicator.classList.remove('active');
        console.log('[Labyrinth] Archive search complete');
      }
    }

    /**
     * Handle image analysis status events
     */
    private handleImageAnalysisStatus(detail: { status: string; caption?: { type: string; caption: string }; error?: string }) {
      if (detail.status === 'analyzing') {
        // Show "analyzing image" in archive indicator temporarily
        if (this.archiveIndicator) {
          const textEl = this.archiveIndicator.querySelector('.archive-text');
          if (textEl) {
            textEl.textContent = 'Kothar is perceiving the image';
          }
          this.archiveIndicator.classList.add('active');
        }
        console.log('[Labyrinth] Image analysis started');
      } else if (detail.status === 'complete' || detail.status === 'error') {
        // Reset archive indicator
        if (this.archiveIndicator) {
          const textEl = this.archiveIndicator.querySelector('.archive-text');
          if (textEl) {
            textEl.textContent = 'Kothar is consulting his archives';
          }
          this.archiveIndicator.classList.remove('active');
        }
        if (detail.status === 'complete') {
          console.log('[Labyrinth] Image analysis complete:', detail.caption?.type);
        } else {
          console.log('[Labyrinth] Image analysis error:', detail.error);
        }
      }
    }

    /**
     * Handle paste event for image attachment
     */
    private handlePaste(e: ClipboardEvent) {
      const items = e.clipboardData?.items;
      if (!items) return;

      for (const item of items) {
        if (item.type.startsWith('image/')) {
          e.preventDefault();
          const file = item.getAsFile();
          if (file) {
            this.processImageFile(file);
          }
          return;
        }
      }
    }

    /**
     * Handle file selection from input
     */
    private handleFileSelect() {
      const file = this.imageInput.files?.[0];
      if (file) {
        this.processImageFile(file);
      }
      // Reset input so same file can be selected again
      this.imageInput.value = '';
    }

    /**
     * Process image file - validate, convert to base64, show preview
     */
    private processImageFile(file: File) {
      // Validate size
      if (file.size > MAX_IMAGE_SIZE) {
        this.showToast('Image too large (max 5MB)');
        return;
      }

      // Validate type
      const validTypes = ['image/png', 'image/jpeg', 'image/webp'];
      if (!validTypes.includes(file.type)) {
        this.showToast('Only PNG, JPEG, and WebP images are supported');
        return;
      }

      // Convert to base64
      const reader = new FileReader();
      reader.onload = (e) => {
        const dataUrl = e.target?.result as string;
        if (dataUrl) {
          this.pendingImage = {
            dataUrl,
            mimeType: file.type,
            sizeBytes: file.size,
          };
          this.showAttachmentPreview(dataUrl);
          console.log('[Labyrinth] Image attached:', file.name, `(${Math.round(file.size / 1024)}KB)`);
        }
      };
      reader.onerror = () => {
        this.showToast('Failed to read image');
      };
      reader.readAsDataURL(file);
    }

    /**
     * Show attachment preview bar with thumbnail
     */
    private showAttachmentPreview(dataUrl: string) {
      this.attachmentThumbnail.src = dataUrl;
      this.attachmentPreview.style.display = 'flex';
    }

    /**
     * Clear pending image and hide preview
     */
    private clearPendingImage() {
      this.pendingImage = null;
      this.attachmentPreview.style.display = 'none';
      this.attachmentThumbnail.src = '';
    }

    /**
     * Validate that a string is a safe image data URL
     */
    private isValidImageDataUrl(url: string): boolean {
      // Strict regex: only allow png/jpeg/webp base64 data URLs
      const dataUrlRegex = /^data:image\/(png|jpeg|webp);base64,[A-Za-z0-9+/]+=*$/;
      return dataUrlRegex.test(url);
    }

    /**
     * Open image in lightbox (uses DOM API to prevent XSS)
     */
    private openLightbox(imageUrl: string) {
      // Validate the URL before using it
      if (!this.isValidImageDataUrl(imageUrl)) {
        console.warn('[Lightbox] Invalid image URL rejected');
        return;
      }

      const lightbox = document.createElement('div');
      lightbox.className = 'image-lightbox';

      // Use DOM API instead of innerHTML to prevent XSS
      const img = document.createElement('img');
      img.src = imageUrl;
      img.alt = 'Full size image';
      lightbox.appendChild(img);

      lightbox.addEventListener('click', () => {
        lightbox.remove();
      });
      document.body.appendChild(lightbox);
    }

    private formatContent(content: string): string {
      // Basic markdown-like formatting
      return content
        .replace(/\*\*(.+?)\*\*/g, '<strong>$1</strong>')
        .replace(/\*(.+?)\*/g, '<em>$1</em>')
        .replace(/`(.+?)`/g, '<code>$1</code>')
        .replace(/\n/g, '<br>');
    }

    private async sendMessage() {
      const query = this.input.value.trim();
      const hasImage = this.pendingImage !== null;

      // Require either text or image
      if ((!query && !hasImage) || this.isLoading) return;

      // Name extraction (instant, no LLM call)
      if (query) {
        const currentUserName = getUserName();
        if (!currentUserName || currentUserName === 'visitor') {
          const extractedName = extractNameHeuristic(query);
          if (extractedName) {
            saveUserName(extractedName);
            // Update placeholder immediately
            this.input.placeholder = `Ask Kothar, ${extractedName}...`;
          }
        }
      }

      this.isLoading = true;
      this.submitBtn.disabled = true;
      this.attachButton.disabled = true;
      this.input.value = '';
      this.emptyState.style.display = 'none';

      // Capture and clear pending image
      const imageAttachment = this.pendingImage;
      this.clearPendingImage();

      // Add user message
      const userMsg: ChatMessage = {
        id: `${Date.now()}_user`,
        role: 'user',
        content: query || 'What do you see in this image?',
        timestamp: Date.now(),
        page: '/labyrinth',
        image: imageAttachment || undefined,
      };
      this.renderMessage(userMsg);

      // Evaluate message for goddess-invoked trigger
      try {
        const triggerManager = getTriggerManager();
        triggerManager.evaluateMessage(query);
      } catch (e) {
        console.warn('[Labyrinth] Trigger evaluation failed:', e);
      }

      // Add loading state (will be converted to streaming message)
      const loadingMsg: ChatMessage = {
        id: 'streaming',
        role: 'assistant',
        content: '',
        timestamp: Date.now()
      };
      const loadingEl = this.renderMessage(loadingMsg, true);
      this.scrollToBottom();

      try {
        // Check if orchestrator is initialized
        if (!this.orchestrator) {
          throw new Error('SoulOrchestrator not initialized');
        }

        // Initialize stream renderer and store reference for callbacks
        this.currentRenderer = new StreamRenderer(loadingEl);
        this.currentRenderer.start();

        // Create promise to wait for response completion
        const responsePromise = new Promise<string>((resolve) => {
          this.pendingResolve = resolve;
        });

        // Send message to orchestrator (Open Souls paradigm)
        // The orchestrator will call onStreamChunk for each chunk,
        // and onResponse when complete (which resolves our promise)
        // Pass image attachment if present
        await this.orchestrator.handleMessage(
          query || 'What do you see in this image?',
          imageAttachment ? { imageAttachment } : undefined
        );

        // Wait for the response to complete (via onResponse callback)
        const finalResponse = await responsePromise;

        // Clear renderer reference
        this.currentRenderer = null;

        // Update element ID for final message
        loadingEl.id = `msg-${Date.now()}_assistant`;

        // Create assistant message record
        const assistantMsg: ChatMessage = {
          id: `${Date.now()}_assistant`,
          role: 'assistant',
          content: finalResponse,
          timestamp: Date.now(),
          page: '/labyrinth'
        };

        // Save to localStorage (strip image dataUrl to save space)
        const thread = this.loadConversation();

        // Create storage-safe version of userMsg (remove large dataUrl)
        const userMsgForStorage: ChatMessage = {
          ...userMsg,
          image: userMsg.image ? {
            ...userMsg.image,
            dataUrl: '', // Don't persist large base64 data
          } : undefined,
        };

        thread.messages.push(userMsgForStorage, assistantMsg);
        thread.lastUpdated = Date.now();

        // Trim if needed
        if (thread.messages.length > 100) {
          thread.messages = thread.messages.slice(-100);
        }

        this.saveConversation(thread);

      } catch (error) {
        console.error('Chat error:', error);
        loadingEl.remove();
        this.currentRenderer = null;

        // Show error message
        const errorMsg: ChatMessage = {
          id: `${Date.now()}_error`,
          role: 'assistant',
          content: "The Oracle's connection wavers. Try again in a moment.",
          timestamp: Date.now()
        };
        this.renderMessage(errorMsg);
      }

      this.isLoading = false;
      this.submitBtn.disabled = false;
      this.attachButton.disabled = false;
      this.input.focus();
      this.scrollToBottom();

      // Update soul state indicator after response
      this.updateSoulState();
    }

    private getVisitorContext() {
      try {
        const memory = JSON.parse(localStorage.getItem('minoan-soul-memory') || '{}');
        return {
          currentPage: '/labyrinth',
          pagesViewed: memory.pagesViewed || [],
          visitCount: memory.visitCount || 1,
          behavioralType: memory.behavioralType || 'explorer'
        };
      } catch {
        return { currentPage: '/labyrinth' };
      }
    }

    private getConversationHistory() {
      const thread = this.loadConversation();
      return thread.messages.slice(-10).map(m => ({
        role: m.role,
        content: m.content
      }));
    }

    private clearConversation() {
      localStorage.removeItem('minoan-soul-conversation');
      this.history.querySelectorAll('.message').forEach(el => el.remove());
      this.emptyState.style.display = 'flex';
      this.input.focus();
    }

    private showToast(message: string) {
      // Create toast element
      const existing = document.querySelector('.labyrinth-toast');
      if (existing) existing.remove();

      const toast = document.createElement('div');
      toast.className = 'labyrinth-toast';
      toast.textContent = message;
      document.body.appendChild(toast);

      // Animate in
      requestAnimationFrame(() => {
        toast.classList.add('is-visible');
      });

      // Remove after delay
      setTimeout(() => {
        toast.classList.remove('is-visible');
        setTimeout(() => toast.remove(), 200);
      }, 2000);
    }

    private scrollToBottom() {
      this.history.scrollTop = this.history.scrollHeight;
    }

    private scrollToMessage(msgId: string) {
      const el = document.getElementById(`msg-${msgId}`);
      if (el) {
        el.scrollIntoView({ behavior: 'smooth', block: 'center' });
        el.classList.add('is-highlighted');
        setTimeout(() => el.classList.remove('is-highlighted'), 2000);
      }
    }
  }

  // Store instance for cleanup
  let labyrinthInstance: LabyrinthChat | null = null;

  // Initialize
  labyrinthInstance = new LabyrinthChat();

  // Handle view transitions - cleanup old instance before creating new
  document.addEventListener('astro:before-swap', () => {
    if (labyrinthInstance) {
      labyrinthInstance.destroy();
      labyrinthInstance = null;
    }
  });

  document.addEventListener('astro:after-swap', () => {
    if (window.location.pathname === '/labyrinth') {
      labyrinthInstance = new LabyrinthChat();
    }
  });
</script>
